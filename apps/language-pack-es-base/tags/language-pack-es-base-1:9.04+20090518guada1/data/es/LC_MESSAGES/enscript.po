# Mensajes en español para GNU enscript.
# Copyright (C) 1996 Free Software Foundation, Inc.
# L. Marcél Barrero M. <barrero@cui.unige.ch>, 1996.
# Revisado y enviado por Enrique Melero <melero@iprolink.ch>
#
msgid ""
msgstr ""
"Project-Id-Version: GNU enscript 1.4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2008-12-05 00:08+0000\n"
"PO-Revision-Date: 2009-04-14 17:15+0000\n"
"Last-Translator: Paco Molinero <paco@byasl.com>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Launchpad-Export-Date: 2009-05-18 21:31+0000\n"
"X-Generator: Launchpad (build Unknown)\n"

#: compat/getopt.c:628
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: compat/getopt.c:652
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `--%s' no admite ningún argumento\n"

#: compat/getopt.c:657
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no admite ningún argumento\n"

#: compat/getopt.c:674 compat/getopt.c:847
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#: compat/getopt.c:703
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción desconocida `--%s'\n"

#: compat/getopt.c:707
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción desconocida `%c%s'\n"

#: compat/getopt.c:733
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción no permitida -- %c\n"

#: compat/getopt.c:736
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción no válida -- %c\n"

#: compat/getopt.c:766 compat/getopt.c:896
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: compat/getopt.c:813
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: compat/getopt.c:831
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite argumentos\n"

#: compat/xalloc.c:70
#, c-format
msgid "xmalloc(): couldn't allocate %d bytes\n"
msgstr "xmalloc(): no se pueden asignar %d bytes\n"

#: compat/xalloc.c:88
#, c-format
msgid "xcalloc(): couldn't allocate %d bytes\n"
msgstr "xcalloc(): no se pudieron asignar %d bytes\n"

#: compat/xalloc.c:109
#, c-format
msgid "xrealloc(): couldn't reallocate %d bytes\n"
msgstr "xrealloc(): no se pudieron reasignar %d bytes\n"

#: compat/regex.c:996
msgid "Success"
msgstr "Éxito"

#: compat/regex.c:997
msgid "No match"
msgstr "No coincide"

#: compat/regex.c:998
msgid "Invalid regular expression"
msgstr "Expresión regular inválida"

#: compat/regex.c:999
msgid "Invalid collation character"
msgstr "Caracter de ordenación inválido"

#: compat/regex.c:1000
msgid "Invalid character class name"
msgstr "Nombre de clase de caracter inválido"

#: compat/regex.c:1001
msgid "Trailing backslash"
msgstr "Barra invertida extra al final"

#: compat/regex.c:1002
msgid "Invalid back reference"
msgstr "Referencia hacia atrás inválida"

#: compat/regex.c:1003
msgid "Unmatched [ or [^"
msgstr "[ o [^ sin pareja"

#: compat/regex.c:1004
msgid "Unmatched ( or \\("
msgstr "( o \\( sin pareja"

#: compat/regex.c:1005
msgid "Unmatched \\{"
msgstr "\\{ sin pareja"

#: compat/regex.c:1006
msgid "Invalid content of \\{\\}"
msgstr "Contenido de  \\{\\} inválido"

#: compat/regex.c:1007
msgid "Invalid range end"
msgstr "Final de rango inválido"

#: compat/regex.c:1008
msgid "Memory exhausted"
msgstr "Memoria agotada"

#: compat/regex.c:1009
msgid "Invalid preceding regular expression"
msgstr "Expresión regular precedente inválida"

#: compat/regex.c:1010
msgid "Premature end of regular expression"
msgstr "Final inesperado de expresión regular"

#: compat/regex.c:1011
msgid "Regular expression too big"
msgstr "La expresión regular es demasiado grande"

#: compat/regex.c:1012
msgid "Unmatched ) or \\)"
msgstr ") o \\) sin pareja"

#: compat/regex.c:5462
msgid "No previous regular expression"
msgstr "No hay ninguna expresión regular previa"

#: src/main.c:968
#, no-c-format
msgid "$3v $-40N $3% pages $4L lines  $E $C"
msgstr "$3v $-40N $3% páginas $4L líneas  $E $C"

# "passwd entry" es la entrada (o el campo) de la contraseña. sv
# Sugiero cambiarlo a "no se pudo obtener la contraseña para el uid=etc.etc" sv
# > No es la contraseña la que no se pudo encontrar (password), sino la línea entera,
# > Un " passwd entry" sería:
# > guest:*:405:100:guest:/dev/null:/dev/null
# > Donde el uid es 405 y el gid 100. Su contraseña (password) es *, que significa que la cuenta
# > está bloqueada. Por eso que lo había traducido como declaración del utilizador en el archivo
# > passwd. (/etc/passwd).
# Bueno, bien. Admitiendo que lo que no se encontró fue la línea entera,
#: src/main.c:1000
#, c-format
msgid "couldn't get passwd entry for uid=%d: %s"
msgstr "No se pudo obtener la contraseña para el uid=%d: %s"

#: src/main.c:1099
#, c-format
msgid "couldn't read config file \"%s/%s\": %s"
msgstr "no se pudo leer el archivo de configuración \"%s/%s\": %s"

#: src/main.c:1103
msgid "I did also try the following directories:"
msgstr "También lo intenté en los siguientes directorios:"

#: src/main.c:1104 src/main.c:1105 src/main.c:1106
#, c-format
msgid "\t%s"
msgstr "\t%s"

#: src/main.c:1107
msgid "\t../lib"
msgstr "\t../lib"

#: src/main.c:1108
msgid "\t../../lib"
msgstr "\t../../lib"

#: src/main.c:1110
msgid "This is probably an installation error.  Please, try to rebuild:"
msgstr ""
"Probablemente se trate de un error de instalación. Por favor intente "
"reconstruir:"

#: src/main.c:1111
msgid "\tmake distclean"
msgstr "\tmake distclean"

#: src/main.c:1112
msgid "\t./configure --prefix=PREFIX"
msgstr "\t./configure --prefix=PREFIX"

#: src/main.c:1113
msgid "\tmake"
msgstr "\tmake"

#: src/main.c:1114
msgid "\tmake check"
msgstr "\tmake check"

#: src/main.c:1115
msgid "\tmake install"
msgstr "\tmake install"

#: src/main.c:1117
msgid "or set the environment variable `ENSCRIPT_LIBRARY' to point to your"
msgstr ""
"o configura la variable de entorno 'ENSCRIPT_LIBRARY' para que apunte a tu"

#: src/main.c:1119
msgid "library directory."
msgstr "directorio de librerías"

#: src/main.c:1191
#, c-format
msgid "unknown encoding: %s"
msgstr "codificación desconocida: %s"

# library=biblioteca, pero me parece que es más corriente (y hasta se entiende mejor),
# cuando se habla de librerías. En spanglish la semana pasada uno de los mails decía
# también que ambas traducciones pueden ser válidas.
# Sí, era Enrique quien lo decía...
# Pero biblioteca es más correcto: Tú vas a una biblioteca a consultar algo,
# pero no a llevártelo a casa. sv
# ¿Consenso? :-)
# En Spanish-GNU nos hemos decidido por biblioteca. sv
#: src/main.c:1210
#, c-format
msgid "couldn't open AFM library: %s"
msgstr "no se pudo abrir la biblioteca AFM: %s"

# "media" es medio de comunicación o "soporte" para comunicar. Si tienen alguna idea
# mejor... otra cosa, en este contexto creo que se refiere sobre todo al papel
# (tipos, tamaños, formatos)
# Para tratar de adaptar los ll y ur habrá que comprender mejor el
# contexto (cf. código fuente).
#
# Sugiero comerse el "Lista de" y dejarlo simplemente
#: src/main.c:1239
#, c-format
msgid ""
"known media:\n"
"name             width\theight\tllx\tlly\turx\tury\n"
"------------------------------------------------------------\n"
msgstr ""
"Soportes conocidos:\n"
"nombre             ancho\tlargo\tllx\tlly\turx\tury\n"
"------------------------------------------------------------\n"

#: src/main.c:1258
#, c-format
msgid "do not know anything about media \"%s\""
msgstr "no se pudo reconocer el soporte \"%s\""

#: src/main.c:1302
#, c-format
msgid ""
"set new marginals for media `%s' (%dx%d): llx=%d, lly=%d, urx=%d, ury=%d\n"
msgstr ""
"Establecer nuevos marginales el medios `%s' (%dx%d): llx=%d, lly=%d, urx=%d, "
"ury=%d\n"

# Yo tengo por norma comenzar por mayúscula cuando el original lo hace.
# Este es el único mensaje (y los que siguen) que no son así.
#: src/main.c:1313
#, c-format
msgid "illegal page label format \"%s\""
msgstr "El formato del nombre de página \"%s\" es incorrecto."

#: src/main.c:1325
#, c-format
msgid "illegal non-printable format \"%s\""
msgstr "El formato no imprimible \"%s\" es incorrecto."

#: src/main.c:1339
#, c-format
msgid "illegal style for wrapped line marker: \"%s\""
msgstr "estilo ilegal para el marcador de línea ajustada: \"%s\""

#: src/main.c:1349
#, c-format
msgid "illegal N-up argument: %d"
msgstr "argumento N-up ilegal: %d"

#: src/main.c:1354
#, c-format
msgid "N-up argument must be power of 2: %d"
msgstr "El argumento N-up debe ser potencia de 2: %d"

#: src/main.c:1431
#, c-format
msgid "malformed underlay position: %s"
msgstr "La posición de pie de página es incorrecta: %s"

#: src/main.c:1454
#, c-format
msgid "illegal underlay style: %s"
msgstr "El estilo del pie de página es incorrecto: %s"

#: src/main.c:1481
#, c-format
msgid ""
"Highlighting is supported for the following languages and file formats:\n"
"\n"
msgstr ""
"El remarcado está disponible para los siguientes lenguajes y formatos de "
"archivos:\n"
"\n"

# ¿Crees que toc es por Table Of Contents?
#  Sí, casi seguro. sv
# Si es así podríamos poner: el archivo índice o el archivo del índice
# Esta línea no existe en la fuente que dispongo para ver qué es el TOC.
# Otra cosa que se puede hacer es poner "el archivo `toc'". sv
# Creo que mejor sería poner índice. Sabemos que toc es lo mismo, pero
# sería mantener una especie de anglicismo fácilmente evitable.
# Bueno, en este caso no sería tan grave: Piensa que hablando de TeX,
# uno puede decir "El archivo .tex, el archivo .dvi y el archivo .log"
#: src/main.c:1662
#, c-format
msgid "couldn't create temporary toc file: %s"
msgstr "no se pudo crear el archivo temporal para el índice: %s"

#: src/main.c:1709
#, c-format
msgid "couldn't stat input file \"%s\": %s"
msgstr "stat() no pudo evaluar archivo de entrada \"%s\": %s"

# Ojo: rewind no es abrir. sv
#   Si, pero ¿vamos a decir rebobinar?
# Uf, la verdad es que es delicado.
# Rebobinar queda bien para cintas magnéticas
# pero para la operación del mismo nombre que puede
# efectuarse con un archivo abierto, no sé. sv
# Si quieres déjalo así, a ver si a algún otro revisor se le ocurre algo. sv
# Y si decimos:
# msgstr "no se pudo localizar el inicio del archivo para el índice: %s"
#: src/main.c:1729
#, c-format
msgid "couldn't rewind toc file: %s"
msgstr "no se pudo rebobinar el archivo para el índice: %s"

#: src/main.c:1735
msgid "Table of Contents"
msgstr "Índice"

#: src/main.c:1768
msgid "no output generated\n"
msgstr "no se generó resultado\n"

#: src/main.c:1773
#, c-format
msgid "output sent to %s\n"
msgstr "salida enviada a %s\n"

# Si supiéramos el contexto sabríamos si el "la" procede o no. sv
# Si si, según el código fuente, son las páginas enviadas a la impresora.
#: src/main.c:1774 src/main.c:1798
msgid "printer"
msgstr "la impresora"

# ¿o sería mejor "faltan"?
# por mí está bien así, pero ¿y el "in"? sv
# > Como se trata de un programa de impresión, pienso que se trata de un trabajo incompleto, por
# > ejemplo, si le indicamos que imprima 3 archivos, y sólo pudo imprimr 2, entonces nos dirá:
# > quedan: 1.  [Queda 1 en la fila de espera :-)]. Para aclarar mejor, esta tarde me bajaré
# > el código fuente para tratar  de ver mejor de qué se trata.
# Espero que el código fuente lo aclare. sv
# Según el código fuente, si se imprime en la impresora, se imprimirá el mensaje anterior:
#  	enviadas a la impresora.
# Si se "imprime" en un archivo (opción -o <outputname>), se imprimirá el mensaje:
# 	quedan en el archivo <outputname>.
#: src/main.c:1776
#, c-format
msgid "output left in %s\n"
msgstr "salida copiadas en %s\n"

#: src/main.c:1794
#, c-format
msgid "[ %d pages * %d copy ]"
msgstr "[ %d páginas * %d copias ]"

#: src/main.c:1797
#, c-format
msgid " sent to %s\n"
msgstr " enviadas a %s\n"

# ¿o sería mejor "faltan"?
# por mí está bien así, pero ¿y el "in"? sv
# > Como se trata de un programa de impresión, pienso que se trata de un trabajo incompleto, por
# > ejemplo, si le indicamos que imprima 3 archivos, y sólo pudo imprimr 2, entonces nos dirá:
# > quedan: 1.  [Queda 1 en la fila de espera :-)]. Para aclarar mejor, esta tarde me bajaré
# > el código fuente para tratar  de ver mejor de qué se trata.
# Espero que el código fuente lo aclare. sv
# Según el código fuente, si se imprime en la impresora, se imprimirá el mensaje anterior:
#  	enviadas a la impresora.
# Si se "imprime" en un archivo (opción -o <outputname>), se imprimirá el mensaje:
# 	quedan en el archivo <outputname>.
#: src/main.c:1800
#, c-format
msgid " left in %s\n"
msgstr " copiadas en %s\n"

#: src/main.c:1805
#, c-format
msgid "%d line(s) were %s\n"
msgstr "%d líneas fueron %s\n"

#: src/main.c:1807
msgid "truncated"
msgstr "cortadas"

#: src/main.c:1807
msgid "wrapped"
msgstr "separadas"

#: src/main.c:1813
#, c-format
msgid "%d characters were missing\n"
msgstr "faltaron %d caracteres\n"

#: src/main.c:1817
msgid "missing character codes (decimal):\n"
msgstr "códigos (en decimal) de los caracteres que faltan:\n"

#: src/main.c:1825
#, c-format
msgid "%d non-printable characters\n"
msgstr "%d caracteres no imprimibles\n"

#: src/main.c:1830
msgid "non-printable character codes (decimal):\n"
msgstr "códigos (en decimal) de los caracteres no imprimibles:\n"

#: src/main.c:1879
#, c-format
msgid "couldn't open printer `%s': %s"
msgstr "no se pudo acceder a la impresora `%s': %s"

#: src/main.c:1888
#, c-format
msgid "couldn't create output file \"%s\": %s"
msgstr "no se pudo crear el archivo de salida \"%s\": %s"

#: src/main.c:1905
#, c-format
msgid "couldn't close output file \"%s\": %s"
msgstr "no se pudo cerrar el archivo de salida \"%s\": %s"

# quotation podría ser "cita" a secas. ¿Qué te parece? sv
# Quedaría "el fin de la cita". sv
# > Acá lo que me parece falta, son las comillas que cierran la citación.
# > No se trata de una citación en sí, sino tal vez de una cadena de caracteres
# > que no está cerrada: "test
# >                           ^
# > Y el carácter a ser impreso (%c) indica qué fin de citación falta: " o ' o `.
# Que sí, que estoy de acuerdo. Lo que digo es cómo se le llama a eso en español.
# La verdad es que no lo sé. sv
#
# Nota: El término correcto es apóstrofo (en inglés sí es "apostrophe").
# Viene en el diccionario de la Real Academia.
# ## Toda mi vida había dicho apóstrofe... Cada día se aprende, ¿verdad?  :-)
#: src/main.c:1963
#, c-format
msgid ""
"syntax error in option string %s=\"%s\":\n"
"missing end of quotation: %c"
msgstr ""
"error de sintaxis en la opción %s=\"%s\":\n"
"falta el apóstrofo %c que indica el final del argumento."

# *******************************************
# A comprender el contexto...
# > Acá creo que significa que algunas opciones pasadas en la línea de comando, no
# > fueron interpretadas porque existían variables de entorno que son prioritarias
# > para definir algunas acciones. (Aunque normalmente es lo contrario que sucede,
# > que las opciones de la línea de comando son prioritarias a las variables de entorno)...
#: src/main.c:1995
#, c-format
msgid ""
"warning: didn't process following options from environment variable %s:\n"
msgstr ""
"atención: no se procesaron las siguientes opciones de la variable de entorno "
"%s:\n"

#: src/main.c:1999
#, c-format
msgid "  option %d = \"%s\"\n"
msgstr "  opción %d = \"%s\"\n"

#: src/main.c:2045
msgid "number of columns must be larger than zero"
msgstr "la cantidad de columnas debe ser mayor que cero"

#: src/main.c:2103
msgid "file alignment must be larger than zero"
msgstr "la alineación del archivo debe ser mayor que cero"

#: src/main.c:2158 src/main.c:2164 src/main.c:2375 src/util.c:415
#, c-format
msgid "malformed font spec: %s"
msgstr "especificación errónea de la fuente: %s"

#: src/main.c:2180
#, c-format
msgid "couldn't find header definition file \"%s.hdr\""
msgstr ""
"no se pudo encontrar el archivo de definición de la cabecera \"%s.hdr\""

#: src/main.c:2224
#, c-format
msgid "must print at least one line per each page: %s"
msgstr "se debe imprimir por lo menos una línea por página: %s"

#: src/main.c:2244
#, c-format
msgid "%s: illegal newline character specifier: '%s': expected 'n' or 'r'\n"
msgstr ""
"%s: carácter de nueva línea no permitido: '%s': se esperaba 'n' o 'r'\n"

#: src/main.c:2333
#, c-format
msgid "malformed argument `%s' for option -W, --option: no comma found"
msgstr ""
"argumento `%s' mal formado para la opción -W, --opción: no se encontró coma"

#: src/main.c:2338
#, c-format
msgid "helper application specification must be single character: %s"
msgstr ""
"La especificación de la aplicación de ayuda puede ser un carácter simple: %s"

#: src/main.c:2434
msgid "slice must be greater than zero"
msgstr "el intervalo debe ser mayor que cero"

#: src/main.c:2515 states/main.c:321
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: src/main.c:2535
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
"  -#                         an alias for option -n, --copies\n"
"  -1                         same as --columns=1\n"
"  -2                         same as --columns=2\n"
"      --columns=NUM          specify the number of columns per page\n"
"  -a, --pages=PAGES          specify which pages are printed\n"
"  -A, --file-align=ALIGN     align separate input files to ALIGN\n"
"  -b, --header=HEADER        set page header\n"
"  -B, --no-header            no page headers\n"
"  -c, --truncate-lines       cut long lines (default is to wrap)\n"
"  -C, --line-numbers[=START]\n"
"                             precede each line with its line number\n"
"  -d                         an alias for option --printer\n"
"  -D, --setpagedevice=KEY[:VALUE]\n"
"                             pass a page device definition to output\n"
"  -e, --escapes[=CHAR]       enable special escape interpretation\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN]... [ARCHIVO]...\n"
"Los argumentos obligatorios para las opciones largas son también\n"
"obligatorios para las opciones cortas.\n"
"  -1                         equivalente a --columns=1\n"
"  -2                         equivalente a --columns=2\n"
"      --columns=NUM          especifica el número de columnas por página\n"
"  -a, --pages=PÁGINAS        especifica las páginas que se imprimirán\n"
"  -A, --file-align=ALIN      alinea los diferentes archivos de entrada\n"
"                             a ALIN\n"
"  -b, --header=CABECERA      define la cabecera de la página\n"
"  -B, --no-header            sin cabecera de página\n"
"  -c, --truncate-lines       corta las líneas largas (por defecto las\n"
"                             divide)\n"
"  -C, --line-numbers         imprime el número de cada línea\n"
"  -d                         un alias para la opción --printer\n"
"  -D, --setpagedevice=CLAVE[:VALOR]\n"
"                             pasa un dispositivo de página a la salida\n"
"  -e, --escapes[=CHAR]       activa la interpretación de las secuencias\n"
"                             especiales de escape\n"

#: src/main.c:2555
#, c-format
msgid "  -E, --highlight[=LANG]     highlight source code\n"
msgstr "  -E, --highlight[=LANG]     resalta el código fuente\n"

#: src/main.c:2558
#, c-format
msgid ""
"  -f, --font=NAME            use font NAME for body text\n"
"  -F, --header-font=NAME     use font NAME for header texts\n"
"  -g, --print-anyway         nothing (compatibility option)\n"
"  -G                         same as --fancy-header\n"
"      --fancy-header[=NAME]  select fancy page header\n"
"  -h, --no-job-header        suppress the job header page\n"
"  -H, --highlight-bars=NUM   specify how high highlight bars are\n"
"  -i, --indent=NUM           set line indent to NUM characters\n"
"  -I, --filter=CMD           read input files through input filter CMD\n"
"  -j, --borders              print borders around columns\n"
"  -J,                        an alias for option --title\n"
"  -k, --page-prefeed         enable page prefeed\n"
"  -K, --no-page-prefeed      disable page prefeed\n"
"  -l, --lineprinter          simulate lineprinter, this is an alias for:\n"
"                               --lines-per-page=66, --no-header, --"
"portrait,\n"
"                               --columns=1\n"
msgstr ""
"  -f, --font=NOMBRE          utiliza la fuente NOMBRE para el cuerpo del "
"texto\n"
"  -F, --header-font=NOMBRE   utiliza la fuente NOMBRE para la cabecera\n"
"  -g, --print-anyway         sin efecto (opción de compatibilidad)\n"
"  -G                         idéntico a --fancy-header\n"
"      --fancy-header[=NOMBRE] selecciona la página de caratula\n"
"  -h, --no-job-header        suprime la página de cabecera.\n"
"  -H, --highlight-bars=NUM   especifica cuán grandes son las barras de "
"marca\n"
"  -i, --indent=NUM           inicializa la sangría a NUM\n"
"  -I, --filter=CMD           lee los ficheros de entrada a través del filtro "
"CMD\n"
"  -j, --borders              imprime bordes alrededor de las columnas\n"
"  -k, --page-prefeed         activa la pre-alimentación de páginas\n"
"  -K, --no-page-prefeed      desactiva la prealimentación de páginas\n"
"  -l, --lineprinter          simula la presencia de una impresora, es un\n"
"                             alias para:\n"
"                               --lines-per-page=66, --no-header,\n"
"                               --portrait, --columns=1\n"

# ¿aficha? Nunca había oido la palabra.
# ¿Se te ocurre alguna otra? sv
# afichar: colocar un afiche, mostrar algo, ¿no?
# Nunca lo había oído, de verdad. sv
# Creo que "modo paisaje" es lo que en España se dice "apaisado".
# lo de portaretrato no le he oído en mi vida. sv
# Es apaisado que nunca oí.
# Si para hacerlo más claro entonces, utilizamos:
#  "  -r, --landscape            imprime a lo largo de la página\n"
#  "  -R, --portrait             imprime a lo ancho de la página\n"
#  "                             (modo estándar)\n"
# Que lo vea otro, a ver qué dice. sv
# También se podría poner "imprime en modo apaisado" e "imprime en modo normal"
#: src/main.c:2576
#, c-format
msgid ""
"  -L, --lines-per-page=NUM   specify how many lines are printed on each "
"page\n"
"  -m, --mail                 send mail upon completion\n"
"  -M, --media=NAME           use output media NAME\n"
"  -n, --copies=NUM           print NUM copies of each page\n"
"  -N, --newline=NL           select the newline character.  Possible\n"
"                             values for NL are: n (`\\n') and r (`\\r').\n"
"  -o                         an alias for option --output\n"
"  -O, --missing-characters   list missing characters\n"
"  -p, --output=FILE          leave output to file FILE.  If FILE is `-',\n"
"                             leave output to stdout.\n"
"  -P, --printer=NAME         print output to printer NAME\n"
"  -q, --quiet, --silent      be really quiet\n"
"  -r, --landscape            print in landscape mode\n"
"  -R, --portrait             print in portrait mode\n"
msgstr ""
"  -L, --lines-per-page=NUM   especifica cuántas líneas se imprimirán en\n"
"                             cada página\n"
"  -m, --mail                 envía un mensaje al finalizar su ejecución.\n"
"  -M, --media=NOMBRE         utiliza el soporte de salida NOMBRE\n"
"  -n, --copies=NUM           imprime NUM copias de cada página\n"
"  -N, --newline=NL           selecciona el carácter de nueva línea.\n"
"                             Los valores posibles son:  n (`\\n') y r (`\\"
"r').\n"
"  -o                         un alias para la opción `--output'\n"
"  -O, --missing-characters   enumera los caracteres que faltan\n"
"  -p, --output=ARCHIVO       coloca la salida en el archivo ARCHIVO.\n"
"                             Si ARCHIVO es `-', envía el resultado\n"
"                             a la salida estándar.\n"
"  -P, --printer=NOMBRE       envía la salida a la impresora NOMBRE\n"
"  -q, --quiet, --silent      sé realmente silencioso\n"
"  -r, --landscape            imprime en modo apaisado\n"
"  -R, --portrait             imprime en modo portaretrato\n"

# ¿Qué puede significar baselineskip? Es la primera vez que oigo hablar de eso.
# En TeX es un parámetro que indica la distancia entre una línea y la que hay
# debajo. sv
# No estoy muy convencido de la traducción de encoding=codificada
# > Para baselineskip, entonces, ¿te parece que digamos distancia entre las líneas?
# > ¿Para encoding qué te parece entonces decir "la entrada de códigos"?
# > Lo que comprendí del sentido de encoding en casi todo el programa, es
# > que puedes codificar tu archivo de entrada de diferentes maneras.
# He cambiado "la talla" por "el tamaño". En España "la talla" suena fatal. sv
# He puesto `form feed' en lugar de form feed, por no ser palabras españolas.
# imprimir -> mostrar em+
#: src/main.c:2592
#, c-format
msgid ""
"  -s, --baselineskip=NUM     set baselineskip to NUM\n"
"  -S, --statusdict=KEY[:VALUE]\n"
"                             pass a statusdict definition to the output\n"
"  -t, --title=TITLE          set banner page's job title to TITLE.  Option\n"
"                             sets also the name of the input file stdin.\n"
"  -T, --tabsize=NUM          set tabulator size to NUM\n"
"  -u, --underlay[=TEXT]      print TEXT under every page\n"
"  -U, --nup=NUM              print NUM logical pages on each output page\n"
"  -v, --verbose              tell what we are doing\n"
"  -V, --version              print version number\n"
"  -w, --language=LANG        set output language to LANG\n"
"  -W, --options=APP,OPTION   pass option OPTION to helper application APP\n"
"  -X, --encoding=NAME        use input encoding NAME\n"
"  -z, --no-formfeed          do not interpret form feed characters\n"
"  -Z, --pass-through         pass through PostScript and PCL files\n"
"                             without any modifications\n"
msgstr ""
"  -s, --baselineskip=NUM     inicializa `baselineskip' a NUM\n"
"  -S, --statusdict=CLAVE[:VALOR]\n"
"                             pasa una definición del `statusdict' a la "
"salida\n"
"  -t, --title=TÍTULO         da el nombre TÍTULO a la ejecución. También\n"
"                             da nombre al archivo de entrada\n"
"  -T, --tabsize=NUM          inicializa el tamaño del tabulador a NUM\n"
"  -u, --underlay[=TEXTO]     muestra TEXTO al pie de cada página\n"
"  -v, --verbose              indica qué está haciendo\n"
"  -V, --version              informa de la versión y termina\n"
"  -X, --encoding=NOMBRE      utiliza la codificación NOMBRE\n"
"  -z, --no-formfeed          no interpreta los caracteres `form feed'\n"
"  -Z, --pass-through         pasa a través de archivos PostScript y PCL\n"
"                             sin ninguna modificación\n"

#: src/main.c:2621
#, c-format
msgid ""
"  --help-highlight           describe all supported --highlight languages\n"
"                             and file formats\n"
"  --highlight-bar-gray=NUM   print highlight bars with gray NUM (0 - 1)\n"
"  --list-media               list names of all known media\n"
"  --margins=LEFT:RIGHT:TOP:BOTTOM\n"
"                             adjust page marginals\n"
"  --mark-wrapped-lines[STYLE]\n"
"                             mark wrapped lines in the output with STYLE\n"
"  --non-printable-format=FMT specify how non-printable chars are printed\n"
msgstr ""
"  --help-highlight           describe todos los idiomas --highlight "
"soportados\n"
"                             y formatos de archivo\n"
"  --highlight-bar-gray=NUM   imprime barras resaltadas con gris NUM (0 - 1)\n"
"  --list-media               lista los nombres de todos los medios "
"conocidos\n"
"  --margins=LEFT:RIGHT:TOP:BOTTOM\n"
"                             ajusta los márgenes de página\n"
"  --mark-wrapped-lines[STYLE]\n"
"                             marca las líneas envueltas en la salida con "
"STYLE\n"
"  --non-printable-format=FMT especifica como se imprimen los caracteres no "
"imprimibles\n"

# Todos los underlay los he traducido como pie de página.
# No es footnote, pero viendo su ubicación en la página,
# es casi lo mismo... ¿alguien tiene otra sugerencia?
#: src/main.c:2642
#, c-format
msgid ""
"  --slice=NUM                print vertical slice NUM\n"
"  --style=STYLE              use highlight style STYLE\n"
"  --swap-even-page-margins   swap left and right side margins for each even\n"
"                             numbered page\n"
"  --toc                      print table of contents\n"
"  --ul-angle=ANGLE           set underlay text's angle to ANGLE\n"
"  --ul-font=NAME             print underlays with font NAME\n"
"  --ul-gray=NUM              print underlays with gray value NUM\n"
"  --ul-position=POS          set underlay's starting position to POS\n"
"  --ul-style=STYLE           print underlays with style STYLE\n"
"  --word-wrap                wrap long lines from word boundaries\n"
msgstr ""
"  --slice=NUM                inicializa el intervalo vertical a NUM\n"
"  --toc                      imprime el índice\n"
"  --ul-angle=ÁNGULO          inicializa la inclinación del texto del pie\n"
"                             de página a ÁNGULO\n"
"  --ul-font=NOMBRE           imprime los pies de página con la\n"
"                             fuente NOMBRE\n"
"  --ul-gray=NUM              imprime los pies de página con el nivel\n"
"                             de gris NUM (0 - 1)\n"
"  --ul-position=POS          inicializa la posición de partida a POS,\n"
"                             para los pies de página\n"
"  --ul-style=STYLE           imprime los pies de página con el estilo STYLE\n"

#: src/main.c:2656
#, c-format
msgid ""
"\n"
"Report bugs to mtr@iki.fi.\n"
msgstr ""
"\n"
"Reporte errores a mtr@iki.fi.\n"

# ¿Qué es prolog?
# > Prolog es un lenguaje de PROgramaciómn LOGica. Se lo utiliza en trabajos
# > de inteligencia artificial o en proyectos para analizar el lenguaje natural.
# > No es la primera vez que veo prolog asociado a un programa que trabaja
# > con código PostScript. (Hay un script que creo acompaña TeX que se llama
# > multi , él también uitiza prolog, al menos la version que tengo acá en una
#: src/psgen.c:325
#, c-format
msgid "couldn't find prolog \"%s\": %s\n"
msgstr "no se pudo encontrar prolog \"%s\": %s\n"

#: src/psgen.c:333
#, c-format
msgid "couldn't find encoding file \"%s.enc\": %s\n"
msgstr "no se pudo encontrar el archivo de códigos \"%s.enc\": %s\n"

#: src/psgen.c:465
#, c-format
msgid "couldn't find header definition file \"%s.hdr\": %s\n"
msgstr ""
"no se pudo encontrar el archivo de definición de la cabecera \"%s.hdr\": %s\n"

#: src/psgen.c:609
#, c-format
msgid "processing file \"%s\"...\n"
msgstr "procesando el archivo \"%s\"...\n"

#: src/psgen.c:907
#, c-format
msgid "EPS file \"%s\" is too large for page\n"
msgstr "el archivo EPS \"%s\" es demasiado grande para la página\n"

#: src/psgen.c:980
msgid "user font encoding can be only the system's default or `ps'"
msgstr ""
"El usuario de la fuente de codificación sólo puede ser el sistema "
"predeterminado `ps'"

#: src/psgen.c:1222
#, c-format
msgid "unknown special escape: %s"
msgstr "secuencia de escape especial desconocida: %s"

#: src/psgen.c:1348
#, c-format
msgid "illegal option %c for ^@epsf escape"
msgstr "opción no permitida %c para la secuencia de escape ^@epsf"

#: src/psgen.c:1354
msgid "malformed ^@epsf escape: no ']' after options"
msgstr ""
"secuencia de escape ^@epsf errónea: falta un ']' después de las opciones"

#: src/psgen.c:1366
#, c-format
msgid ""
"too long file name for ^@epsf escape:\n"
"%.*s"
msgstr ""
"nombre de archivo demasiado largo para la secuencia de escape ^@epsf:\n"
"%.*s"

# Sugerencia: Fin de archivo (EOF) inesperado ... sv
#: src/psgen.c:1370
msgid "unexpected EOF while scanning ^@epsf escape"
msgstr ""
"Fin de archivo (EOF) inesperado mientras se examinaba la secuencia\n"
"de escape ^@epfs"

#: src/psgen.c:1376
msgid "malformed ^@epsf escape: no '{' found"
msgstr "secuencia de escape ^@epsf errónea: no se encontró '{'"

#: src/psgen.c:1434
#, c-format
msgid "malformed %s escape: no '{' found"
msgstr "secuencia de escape %s errónea: no se encontró '{'"

#: src/psgen.c:1448
#, c-format
msgid ""
"too long argument for %s escape:\n"
"%.*s"
msgstr ""
"argumento demasiado largo para la secuencia de escape %s:\n"
"%.*s"

#: src/psgen.c:1468
#, c-format
msgid "malformed font spec for ^@font escape: %s"
msgstr ""
"especificación de fuente errónea para la secuencia de escape ^@font: %s"

#: src/psgen.c:1505
#, c-format
msgid "malformed color spec for ^@%s escape: %s"
msgstr "especificación de color malformada la secuencia de escape ^@%s: %s"

#: src/psgen.c:1529
#, c-format
msgid "invalid value for ^@shade escape: %s"
msgstr "valor incorrecto para la secuencia de escape ^@shade: %s"

#: src/psgen.c:1537
#, c-format
msgid "invalid value for ^@bggray escape: %s"
msgstr "valor incorrecto para la secuencia de escape ^@shade: %s"

#: src/psgen.c:2438
#, c-format
msgid "couldn't open EPS file \"%s\": %s\n"
msgstr "no se pudo abrir el archivo EPS \"%s\": %s\n"

#: src/psgen.c:2475
#, c-format
msgid "EPS file \"%s\" does not start with \"%%!\" magic\n"
msgstr "el archivo EPS \"%s\" no comienza con el código \"%%!\"\n"

#: src/psgen.c:2500
#, c-format
msgid ""
"EPS file \"%s\" contains malformed %%%%BoundingBox row:\n"
"\"%.*s\"\n"
msgstr ""
"el archivo EPS \"%s\" tiene una línea %%%%BoundingBox errónea:\n"
"\"%.*s\"\n"

#: src/psgen.c:2525
#, c-format
msgid "EPS file \"%s\" is not a valid EPS file\n"
msgstr "el archivo EPS \"%s\" no es un archivo EPS válido\n"

#: src/psgen.c:2667
#, c-format
msgid "passing through all input files for output language `%s'\n"
msgstr ""
"pasando por todos los archivos de entrada para la salida de idiomas `%s'\n"

#: src/psgen.c:2719
#, c-format
msgid "passing through %s file \"%s\"\n"
msgstr "pasando a través del archivo %s \"%s\"\n"

#: src/psgen.c:2822
#, c-format
msgid "couldn't create temporary divert file: %s"
msgstr "no se puede crear el archivo divert temporal: %s"

#: src/psgen.c:2839
#, c-format
msgid "couldn't rewind divert file: %s"
msgstr "no se pudo rebobinar el archivo temporal: %s"

#: src/util.c:95
#, c-format
msgid "missing argument: %s"
msgstr "argumento incorrecto: %s"

#: src/util.c:185 src/util.c:213
#, c-format
msgid "illegal value \"%s\" for option %s"
msgstr "valor \"%s\" incorrecto para la opción %s"

#: src/util.c:201
#, c-format
msgid "invalid value \"%s\" for option %s"
msgstr "valor \"%s\" no permitido para la opción %s"

#: src/util.c:439
#, c-format
msgid "illegal option: %s"
msgstr "opción incorrecta: %s"

#: src/util.c:616
#, c-format
msgid "%s:%d: %%Format: no name"
msgstr "%s:%d: %%Format: sin nombre"

# Sinceramente, creo que el "maxlen" no habría que traducirlo. sv
# > Había pensado en eso, pero como no se trata de ninguna variable, sino
# > sólo de una referencia a la longitud máxima permitida...
# Entonces, si de verdad crees que es así, pon "la longitud máxima es %d"
# Por si acaso (a lo mejor es el nombre interno de la variable), lo dejaría
#: src/util.c:627
#, c-format
msgid "%s:%d: %%Format: too long name, maxlen=%d"
msgstr ""
"%s:%d: %%Format: nombre demasiado largo. La longitud máxima permitida es %d"

#: src/util.c:650
#, c-format
msgid "%s:%d: %%Format: name \"%s\" is already defined"
msgstr "%s:%d: %%Format: el nombre \"%s\" ya ha sido definido"

#: src/util.c:671
#, c-format
msgid "%s:%d: %%HeaderHeight: no argument"
msgstr "%s:%d: %%HeaderHeight: sin argumento"

#: src/util.c:693
#, c-format
msgid "%s:%d: %%FooterHeight: no argument"
msgstr "%s:%d: %%FooterHeight: sin argumento"

#: src/util.c:840
#, c-format
msgid "%s: warning: font size is negative\n"
msgstr "%s: advertencia: el tamaño de la fuente es negativo\n"

#: src/util.c:842
#, c-format
msgid "%s: warning: font width is negative\n"
msgstr "%s: advertencia: el ancho de la fuente es negativo\n"

#: src/util.c:844
#, c-format
msgid "%s: warning: font height is negative\n"
msgstr "%s: advertencia: la altura de la fuente es negativa\n"

#: src/util.c:863
#, c-format
msgid "reading AFM info for font \"%s\"\n"
msgstr "leyendo la información AFM para la fuente \"%s\"\n"

#: src/util.c:896
#, c-format
msgid "couldn't open AFM file for font \"%s\", using default\n"
msgstr ""
"no se pudo abrir el archivo AFM para la fuente \"%s\", se usará\n"
"la definición por defecto\n"

#: src/util.c:903
#, c-format
msgid "couldn't open AFM file for the default font: %s"
msgstr "no se pudo abrir el archivo AFM para la fuente: %s"

# cargando, ¿no? sv
# > Cargando sería copiar hacia la máquina, de algún lado, en éste caso
# > se trata de copiar la fuente hacia la impresora.... aunque de todas maneras
#: src/util.c:1092
#, c-format
msgid "downloading font \"%s\"\n"
msgstr "cargando la fuente \"%s\"\n"

#: src/util.c:1097
#, c-format
msgid "couldn't open font description file \"%s\": %s\n"
msgstr "no se pudo abrir el archivo de descripción \"%s\" de la fuente: %s\n"

#: src/util.c:1389
#, c-format
msgid "%s: too long format for %%D{} escape"
msgstr "%s: formato demasiado largo para la secuencia de escape %%D{}"

#: src/util.c:1474
#, c-format
msgid "%s: unknown `%%' escape `%c' (%d)"
msgstr "%s: secuencia de escape desconocida `%%' `%c' (%d)"

#: src/util.c:1512
#, c-format
msgid "%s: no closing ')' for $() escape"
msgstr "%s: falta el ')' para la secuencia de escape $()"

#: src/util.c:1515
#, c-format
msgid "%s: too long variable name for $() escape"
msgstr ""
"%s: nombre de variable demasiado largo para la secuancia de escape $()"

#: src/util.c:1542
#, c-format
msgid "%s: too long format for $D{} escape"
msgstr "%s: formato demasiado largo para la secuencia de escape $D{}"

#: src/util.c:1630
#, c-format
msgid "%s: unknown `$' escape `%c' (%d)"
msgstr "%s: secuencia de escape `$' `%c' (%d) desconocida"

#: src/util.c:1821
#, c-format
msgid "malformed float dimension: \"%s\""
msgstr "dimensión de números reales errónea: \"%s\""

#: src/util.c:1943
#, c-format
msgid "couldn't open input filter \"%s\" for file \"%s\": %s"
msgstr ""
"no se pudo abrir el filtro de entrada \"%s\" para el archivo \"%s\": %s"

#: src/util.c:1960
#, c-format
msgid "couldn't open input file \"%s\": %s"
msgstr "no se pudo abrir el archivo de entrada \"%s\": %s"

#: src/mkafmmap.c:174
#, c-format
msgid "file=%s\n"
msgstr "archivo=%s\n"

#: src/mkafmmap.c:174
msgid "stdout"
msgstr "salida estándard"

#: src/mkafmmap.c:182
#, c-format
msgid "%s: couldn't open output file \"%s\""
msgstr "%s: no se pudo abrir el archivo de salida \"%s\""

# library=biblioteca, pero me parece que es más corriente (y hasta se entiende mejor),
# cuando se habla de librerías. En spanglish la semana pasada uno de los mails decía
# también que ambas traducciones pueden ser válidas.
# Sí, era Enrique quien lo decía...
# Pero biblioteca es más correcto: Tú vas a una biblioteca a consultar algo,
# pero no a llevártelo a casa. sv
# ¿Consenso? :-)
# En Spanish-GNU nos hemos decidido por biblioteca. sv
#: src/mkafmmap.c:196
msgid "couldn't create AFM library"
msgstr "no se pudo crear la biblioteca AFM"

#: src/mkafmmap.c:245
#, c-format
msgid ""
"Usage: %s [OPTION]... FILE...\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
"  -h, --help              print this help and exit\n"
"  -p, --output-file=NAME  print output to file NAME (default file is\n"
"                          font.map).  If FILE is `-', leavy output to\n"
"                          stdout.\n"
"  -V, --version           print version number\n"
msgstr ""
"Uso: %s [OPCIÓN]... ARCHIVO...\n"
"Argumentos obligatorios de las opciones largas son obligatorios para las "
"opciones cortas también.\n"
"-h, --help imprime esta ayuda y salga\n"
"-p, --output-file=NOMBRE imprime la salida en el archivo NOMBRE (el archivo "
"por defecto es\n"
"font.map). Si ARCHIVO es `-', la salida será\n"
"stdout.\n"
"-V, --version imprime la versión actual\n"

#: states/lex.l:65 states/lex.l:71
msgid "error: EOF in comment"
msgstr "error: EOF (Fin de Archivo ) en comentario"

#: states/lex.l:95
msgid "error: EOF in string constant"
msgstr "error: EOF (Fin de Archivo) en constante de serie"

#: states/lex.l:202
msgid "error: EOF in regular expression"
msgstr "error: EOF (Fin de Archivo) en expression regular"

#: states/main.c:199
#, c-format
msgid "states for GNU %s %s"
msgstr "condiciones para GNU %s %s"

#: states/main.c:255
#, c-format
msgid "%s: malformed variable definition \"%s\"\n"
msgstr "%s: definición de variable malformada \"%s\"\n"

#: states/main.c:283
#, c-format
msgid "%s: couldn't create output file \"%s\": %s\n"
msgstr "%s: no se pudo crear el archivo de salida \"%s\": %s\n"

#: states/main.c:314
#, c-format
msgid "%s: unknown warning level `%s'\n"
msgstr "%s: nivel de aviso desconocido `%s'\n"

#: states/main.c:363 states/main.c:399 states/prims.c:1377 states/utils.c:229
#, c-format
msgid "%s: out of memory\n"
msgstr "%s: memoria agotada\n"

#: states/main.c:424
#, c-format
msgid "%s: couldn't open input file `%s': %s\n"
msgstr "%s: no se pudo abrir el archivo de entrada \"%s\": %s\n"

#: states/main.c:448
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Uso: %s [OPCIÓN]... [ARCHIVO]...\n"
"Los argumentos obligatorios para las opciones largas lo son también para las "
"cortas.\n"

#: states/main.c:452
#, c-format
msgid ""
"  -D, --define=VAR=VAL       define variable VAR to have value VAR\n"
"  -f, --file=NAME            read state definitions from file NAME\n"
"  -h, --help                 print this help and exit\n"
"  -o, --output=NAME          save output to file NAME\n"
"  -p, --path=PATH            set the load path to PATH\n"
"  -s, --state=NAME           start from state NAME\n"
"  -v, --verbose              increase the program verbosity\n"
"  -V, --version              print version number\n"
"  -W, --warning=LEVEL        set the warning level to LEVEL\n"
msgstr ""
"  -D, --define=VAR=VAL       define la variable VAR para tener valor VAR\n"
"  -f, --file=NAME            lee las definiciones de estado del archivo "
"NAME\n"
"  -h, --help                 muestra la ayuda y sale\n"
"  -o, --output=NAME          guarda la salida en el archivo NAME\n"
"  -p, --path=PATH            establece la ruta de carga a PATH\n"
"  -s, --state=NAME           inicia desde el estado NAME\n"
"  -v, --verbose              aumenta la información del programa\n"
"  -V, --version              muestra el número de versión\n"
"  -W, --warning=LEVEL        establece el nivel de aviso a LEVEL\n"

#: states/prims.c:46
#, c-format
msgid "%s:%d: %s: too few arguments\n"
msgstr "%s:%d: %s: pocos argumentos\n"

#: states/prims.c:56
#, c-format
msgid "%s:%d: %s: too many arguments\n"
msgstr "%s:%d: %s: demasiados argumentos\n"

#: states/prims.c:109 states/prims.c:129 states/prims.c:255 states/prims.c:428
#: states/prims.c:903
#, c-format
msgid "%s:%d: %s: illegal argument type\n"
msgstr "%s:%d: %s: tipo de argumento ilegal\n"

#: states/prims.c:470
#, c-format
msgid "%s: panic: "
msgstr "%s: panico: "

#: states/prims.c:504
#, c-format
msgid "%s:%d: %s: malformed version string `%s'\n"
msgstr "%s:%d: %s: cadena de versión malformada `%s'\n"

#: states/prims.c:519
#, c-format
msgid ""
"%s: FATAL ERROR: States version %s or higher is required for this script\n"
msgstr ""
"%s: ERROR FATAL ERROR: Se requiere una versión de estado %s o mayor para "
"este programa\n"

#: states/prims.c:610 states/prims.c:1276
#, c-format
msgid "%s:%d: %s: start offset is bigger than end offset\n"
msgstr "%s:%d: %s: la posición de comienzo es mayor de la de final\n"

#: states/prims.c:619 states/prims.c:635 states/prims.c:1282
#, c-format
msgid "%s:%d: %s: offset out of range\n"
msgstr "%s:%d: %s: posición fuera de rango\n"

#: states/prims.c:653
#, c-format
msgid "%s:%d: %s: illegal argument\n"
msgstr "%s:%d: %s: argumento ilegal\n"

#: states/prims.c:700
#, c-format
msgid "%s:%d: %s: illegal regexp character syntax: %c\n"
msgstr "%s:%d: %s: sintaxis de carácter regexp ilegal: %c\n"

#: states/prims.c:915
#, c-format
msgid "%s:%d: %s: couldn't define state `%s'\n"
msgstr "%s:%d: %s: no se pudo definir el estado `%s'↵\n"

#: states/prims.c:1012
#, c-format
msgid "%s: primitive `%s': too few arguments for format\n"
msgstr "%s: primitiva `%s': pocos argumentos para el formato\n"

#: states/prims.c:1040
#, c-format
msgid "%s:%d: %s: argument %d doesn't match format\n"
msgstr "%s:%d: %s: el argumento %d no coincide con el formato\n"

#: states/prims.c:1080
#, c-format
msgid "%s:%d: %s: no extra options can be specified for %%s\n"
msgstr "%s:%d: %s: No se pueden especificar opciones extras para %%s\n"

#: states/prims.c:1089
#, c-format
msgid "%s:%d: %s: illegal type specifier `%c'\n"
msgstr "%s:%d: %s: especificador de tipo ilegal `%c'\n"

#: states/process.c:117
#, c-format
msgid "%s: undefined state `%s'\n"
msgstr "%s: estado indefinido `%s'\n"

#: states/process.c:198
#, c-format
msgid "%s: error: undefined variable `%s'\n"
msgstr "%s: error: variable indefinida `%s'\n"

#: states/process.c:292
#, c-format
msgid "%s: undefined super state `%s'\n"
msgstr "%s: superestado no definido `%s'\n"

# pipe es una palabra delicada. Yo le he traducido por "tubería" en recode
# Enrique ha puesto "tubería (pipe)" en glibc.
# Otros lo han traducido como "canalización" o "desviación".
# En cualquier caso, no sería un pipe "con el comando" sino "hacia el comando" sv
# Me suena medio feo lo de tubería, pero si son ya dos los que lo tradujeron así...
#: states/utils.c:262
#, c-format
msgid "%s:%d: couldn't compile regular expression \"%s\": %s\n"
msgstr "%s:%d: no se puede compilar la expresión regular \"%s\": %s\n"

#: states/utils.c:451 states/utils.c:479
#, c-format
msgid "%s: ouf of memory"
msgstr "%s: memoria agotada"

#: states/utils.c:456
#, c-format
msgid "warning: redefining state `%s'"
msgstr "aviso: redefiniendo estado `%s'"

#: states/utils.c:483
#, c-format
msgid "%s:%d: warning: redefining subroutine `%s'\n"
msgstr "%s:%d: aviso: redefiniendo subrutina `%s'\n"

#: states/utils.c:580
#, c-format
msgid "%s:%d: error: undefined variable `%s'\n"
msgstr "%s:%d: error: variable indefinida `%s'\n"

#: states/utils.c:618
#, c-format
msgid "%s:%d: error: couldn't set variable `%s'\n"
msgstr "%s:%d: error: no se puede establecer la variable `%s'\n"

#: states/utils.c:769
#, c-format
msgid "%s:%d: error: expression between illegal types\n"
msgstr "%s:%d: error: expresión en medio de tipos ilegales\n"

#: states/utils.c:867
#, c-format
msgid "%s:%d: error: too few arguments for subroutine\n"
msgstr "%s:%d: error: no hay suficientes variables para la subrutina\n"

#: states/utils.c:874
#, c-format
msgid "%s:%d: error: too many arguments for subroutine\n"
msgstr "%s:%d: error: demasiados argumentos para la subrutina\n"

#: states/utils.c:928
#, c-format
msgid "%s:%d: error: undefined procedure `%s'\n"
msgstr "%s:%d: error: procedimiento no definido '%s'\n"

#: states/utils.c:1020
#, c-format
msgid "%s:%d: error: illegal lvalue for assignment\n"
msgstr "%s:%d: error: lvalue ilegal para la firma\n"

#: states/utils.c:1028 states/utils.c:1112
#, c-format
msgid "%s:%d: error: array reference index is not integer\n"
msgstr "%s:%d: error: el índice de referencia de la matriz no es un entero\n"

#: states/utils.c:1034
#, c-format
msgid "%s:%d: error: negative array reference index\n"
msgstr "%s:%d: error: índice de referencia de la matriz negativo\n"

#: states/utils.c:1085
#, c-format
msgid "%s:%d: error: illegal rvalue for string assignment\n"
msgstr "%s:%d: error: rvalor ilegal para la asignación de cadena\n"

#: states/utils.c:1104
#, c-format
msgid "%s:%d: error: illegal type for array reference\n"
msgstr "%s:%d: error: tipo ilegal para la referencia de matriz\n"

#: states/utils.c:1121
#, c-format
msgid "%s:%d: error: array reference index out of rance\n"
msgstr "%s:%d: error: índice de referencia de matriz fuera de rango\n"

#: states/utils.c:1347
#, c-format
msgid "%s: couldn't open definition file `%s': %s\n"
msgstr "%s: no se pudo abrir el archivo de descripción`%s': %s\n"

#: states/utils.c:1403
#, c-format
msgid "%s: autoloading `%s' from `%s'\n"
msgstr "%s: autocargando '%s' desde '%s'\n"

#: src/main.c:2610
#, c-format
msgid ""
"Long-only options:\n"
"  --color[=bool]             create color outputs with states\n"
"  --continuous-page-numbers  count page numbers across input files.  Don't\n"
"                             restart numbering at beginning of each file.\n"
"  --download-font=NAME       download font NAME\n"
"  --extended-return-values   enable extended return values\n"
"  --filter-stdin=NAME        specify how stdin is shown to the input filter\n"
"  --footer=FOOTER            set page footer\n"
"  --h-column-height=HEIGHT   set the horizontal column height to HEIGHT\n"
"  --help                     print this help and exit\n"
msgstr ""

#: src/main.c:2632
#, c-format
msgid ""
"  --nup-columnwise           layout pages in the N-up printing columnwise\n"
"  --nup-xpad=NUM             set the page x-padding of N-up printing to NUM\n"
"  --nup-ypad=NUM             set the page y-padding of N-up printing to NUM\n"
"  --page-label-format=FMT    set page label format to FMT\n"
"  --ps-level=LEVEL           set the PostScript language level that "
"enscript\n"
"                             should use\n"
"  --printer-options=OPTIONS  pass extra options to the printer command\n"
"  --rotate-even-pages        rotate even-numbered pages 180 degrees\n"
msgstr ""
