# Mensajes en español para GNU flex.
# Copyright (C) 1997 Free Software Foundation, Inc.
# Nicolás García-Pedrajas <ngarcia-pedrajas@acm.org>, 1997.
# ## 23 de septiembre de 1996,
# ## Finaliza la tradución y la dejo para revisión
# ## No me machaquéis mucho, es la primera que hago.
#
# Gracias a Nicolás Fernández García que me ha sugerido algunas ideas.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU flex 2.5.8\n"
"Report-Msgid-Bugs-To: flex-devel@lists.sourceforge.net\n"
"POT-Creation-Date: 2008-02-26 16:34-0500\n"
"PO-Revision-Date: 2009-03-24 18:38+0000\n"
"Last-Translator: Paco Molinero <paco@byasl.com>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Launchpad-Export-Date: 2009-04-11 08:29+0000\n"
"X-Generator: Launchpad (build Unknown)\n"

# El estado (?) sv
#: dfa.c:61
#, c-format
msgid "State #%d is non-accepting -\n"
msgstr "El estado #%d es no-aceptar -\n"

#: dfa.c:124
msgid "dangerous trailing context"
msgstr "contexto posterior peligroso"

#: dfa.c:166
#, c-format
msgid " associated rule line numbers:"
msgstr " números de línea asociados a la regla:"

#: dfa.c:202
#, c-format
msgid " out-transitions: "
msgstr " fin de transiciones: "

#: dfa.c:210
#, c-format
msgid ""
"\n"
" jam-transitions: EOF "
msgstr ""
"\n"
" transiciones de bloqueo: fin de archivo (EOF) "

# Teste no lo he oído en mi vida. ¿te suena mal test a secas?
# o quizá ¿examen de consistencia? em
# Pongo comillas a la función em
# Con teste me estoy haciendo famoso, cada vez que lo escribo
# me lo preguntan. Lo que ocurre es que teste es el término que ha
# aceptado la Real Academia, por eso creo que debíamos usarlo. ng
# Bueno, no vamos a ser más papistas que el Papa, pero que a mí me
# sigue sonando raro em
# pues el verbo es testar, ¿cómo te suena? ng+
#
# Sugiero usar prueba o comprobación. sv
#: dfa.c:341
msgid "consistency check failed in epsclosure()"
msgstr "el teste de consistencia falló en `epsclosure()'"

# ¿Qué tal volcado? em
# ok, a mí tampoco me gustaba descarga ng
#: dfa.c:429
msgid ""
"\n"
"\n"
"DFA Dump:\n"
"\n"
msgstr ""
"\n"
"\n"
"Volcado AFD:\n"
"\n"

#: dfa.c:604
msgid "could not create unique end-of-buffer state"
msgstr "no se pudo crear un estado único de final-de-buffer"

#: dfa.c:625
#, c-format
msgid "state # %d:\n"
msgstr "estado # %d:\n"

#: dfa.c:785
msgid "Could not write yynxt_tbl[][]"
msgstr "No se pudo escribir yynxt_tbl[][]"

#: dfa.c:1052
msgid "bad transition character detected in sympartition()"
msgstr "carácter de transición erróneo detectado en sympartition()"

#: gen.c:478
msgid ""
"\n"
"\n"
"Equivalence Classes:\n"
"\n"
msgstr ""
"\n"
"\n"
"Clases de equivalencia:\n"
"\n"

#: gen.c:662 gen.c:691 gen.c:1215
#, c-format
msgid "state # %d accepts: [%d]\n"
msgstr "el estado # %d acepta: [%d]\n"

#: gen.c:1110
#, c-format
msgid "state # %d accepts: "
msgstr "el estado # %d acepta: "

#: gen.c:1157
msgid "Could not write yyacclist_tbl"
msgstr "No se pudo escribir yyacclist_tbl"

#: gen.c:1233
msgid "Could not write yyacc_tbl"
msgstr "No se pudo escribir yyacc_tbl"

#: gen.c:1248 gen.c:1633 gen.c:1656
msgid "Could not write ecstbl"
msgstr "No se pudo escribir ecstbl"

# ¿No sería mejor "MetaEquivalencia" o "Meta-Equivalencia"? sv
# yo prefiero como está, es el mismo caso de metafísica ng+
#: gen.c:1271
msgid ""
"\n"
"\n"
"Meta-Equivalence Classes:\n"
msgstr ""
"\n"
"\n"
"Clases de metaequivalencia:\n"

#: gen.c:1293
msgid "Could not write yymeta_tbl"
msgstr "No se pudo escribir yymeta_tbl"

#: gen.c:1354
msgid "Could not write yybase_tbl"
msgstr "No se pudo escribir yybase_tbl"

#: gen.c:1388
msgid "Could not write yydef_tbl"
msgstr "No se pudo escribir yydef_tbl"

#: gen.c:1428
msgid "Could not write yynxt_tbl"
msgstr "No se puede escribir yynxt_tbl"

#: gen.c:1464
msgid "Could not write yychk_tbl"
msgstr "No se puede escribir yychk_tbl"

#: gen.c:1618 gen.c:1647
msgid "Could not write ftbl"
msgstr "No se puede escribir ftbl"

#: gen.c:1624
msgid "Could not write ssltbl"
msgstr "No se puede escribir ssltbl"

#: gen.c:1675
msgid "Could not write eoltbl"
msgstr "No se puede escribir eoltbl"

#: gen.c:1735
msgid "Could not write yynultrans_tbl"
msgstr "No se puede escribir yynultrans_tbl"

# ¿coincidencia?, es la traducción habitual em
# La traducción de match no me gusta pero no encuentro otra
# Sugerencia: satisface, encaja, es aplicable. sv
# match se traduce por emparejar cuando se usa para emparejar una llave
# abierta con una cerrada, por ejemplo, pero no cuando se trata de ver
# si una regla "matches" o no "matches".
# creo que aplicar no qeuda mal ng+
#: main.c:189
msgid "rule cannot be matched"
msgstr "la regla no se puede aplicar"

# ## re-redacto el mensaje. sv
#: main.c:194
msgid "-s option given but default rule can be matched"
msgstr ""
"se ha especificado la opción -s pero se puede aplicar la regla por defecto"

#: main.c:234
msgid "Can't use -+ with -l option"
msgstr "No se puede usar -+ con la opción -l"

#: main.c:237
msgid "Can't use -f or -F with -l option"
msgstr "No se pueden usar las opciones -f o -F con la opción -l"

#: main.c:241
msgid "Can't use --reentrant or --bison-bridge with -l option"
msgstr "No puede utilizar --reentrant o --bisson-bridge con la opción -l"

# ¿juntos o juntas?
# Creo que está bien así em
# ok ng
#: main.c:278
msgid "-Cf/-CF and -Cm don't make sense together"
msgstr "-Cf/-CF y -Cm no tienen sentido juntos"

# no se si poner y ó e
# A mí tambien me hubiese pasado, creo que está bien así em
# entonces lo dejo ng
# Yo creo que en este caso no hace falta porque se leería así:
# "menos ce efe o menos ce efe mayúscula y menos I son incompatibles". sv
#: main.c:281
msgid "-Cf/-CF and -I are incompatible"
msgstr "-Cf/-CF e -I son incompatibles"

#: main.c:285
msgid "-Cf/-CF are incompatible with lex-compatibility mode"
msgstr "-Cf/-CF son incompatibles con el modo de compatibilidad con lex"

#: main.c:290
msgid "-Cf and -CF are mutually exclusive"
msgstr "-Cf y -CF son mutuamente excluyentes"

#: main.c:294
msgid "Can't use -+ with -CF option"
msgstr "No se puede usar -+ con la opción -CF"

#: main.c:297
#, c-format
msgid "%array incompatible with -+ option"
msgstr "%array incompatible con la opción -+"

#: main.c:302
msgid "Options -+ and --reentrant are mutually exclusive."
msgstr "Opciones -+ y --reentrant son mutuamente exclusivas."

#: main.c:305
msgid "bison bridge not supported for the C++ scanner."
msgstr "bison bridge no esta soportado por el escáner C++."

#: main.c:360 main.c:406
#, c-format
msgid "could not create %s"
msgstr "no se pudo crear %s"

#: main.c:419
msgid "could not write tables header"
msgstr "no se pudo escribir las cabeceras de las tablas"

# Lo mismo con skeleton, máscara o modelo em
# lo mismo de antes ng
# Lo mismo que antes :) em
# idem ng+
#: main.c:423
#, c-format
msgid "can't open skeleton file %s"
msgstr "no se puede abrir el archivo de esquema %s"

# Skeleton se puede traducir por máscara, o por modelo em
# Sí, lo estuve considerando. Pero el eskeleton file es un fichero que
# le indica a flex la forma como tratar el fichero de entrada, y por eso me
# perece que se puede poner mejor esquema, en el sentido de esquema de
# comportamiento, como en algorítmica ng
# No me has convencido nada. Esquema es una cosa, y esquema de comportamiento
# otra muy distinta. No hay mucha gente que asocie las dos cosas.
# Por otro lado, ya que es una cosa que acepta sólo a los muy avanzados
# usuarios, creo que no hace falta buscar palabras que no significan lo que
# son. Todos los que sepan qué es el eskeleton file sabrán lo que es el archivo
# de máscara, pero por otro lado lo del archivo de esquema puede confundir
# a los profanos en la materia, pensando que se refiere al propio scanner.
# No le veo ninguna ventaja a usar esquema, y sí dos inconvenientes em
# que decida una tercera persona
#
# ## Cambio "leyendo" por "al leer", como en otras traducciones. sv
#: main.c:505
#, c-format
msgid "input error reading skeleton file %s"
msgstr "error de entrada al leer el archivo de esquema %s"

# Otra vez :) em
#: main.c:509
#, c-format
msgid "error closing skeleton file %s"
msgstr "error al cerrar el archivo de esquema %s"

# Lo mismo, archivo de seguridad? em
#: main.c:694
#, c-format
msgid "error creating header file %s"
msgstr "error al crear el archivo de cabecera %s"

#: main.c:702
#, c-format
msgid "error writing output file %s"
msgstr "error al escribir el archivo de salida %s"

#: main.c:706
#, c-format
msgid "error closing output file %s"
msgstr "error al cerrar el archivo de salida %s"

#: main.c:710
#, c-format
msgid "error deleting output file %s"
msgstr "error al borrar el archivo de salida %s"

# Copia de seguridad? em
# Sugerencia: No hay retroceso. sv
#: main.c:717
#, c-format
msgid "No backing up.\n"
msgstr "Sin retroceso.\n"

#: main.c:721
#, c-format
msgid "%d backing up (non-accepting) states.\n"
msgstr "%d estados de retroceso (no-aceptación).\n"

# Esta frase no me convence demasiado. Si tradujésemos de español
# a inglés lo que hay ahora en español diría algo así como:
# "Compressed tables are always back up"
# (supuesto que back es irregular y su pasado/participio es back y no backed,
# que ahora mismo no me acuerdo). sv
#: main.c:725
#, c-format
msgid "Compressed tables always back up.\n"
msgstr "Las tablas comprimidas siempre implican un retraso.\n"

# Lo mismo, archivo de seguridad? em
#: main.c:728
#, c-format
msgid "error writing backup file %s"
msgstr "error al escribir el archivo de seguridad %s"

#  En todas las traducciones que ha aparecido
#  he sugerido el uso de copia de seguridad em
# ok ng
#: main.c:732
#, c-format
msgid "error closing backup file %s"
msgstr "error al cerrar el archivo de copia de seguridad %s"

#: main.c:737
#, c-format
msgid "%s version %s usage statistics:\n"
msgstr "%s versión %s estadísticas de uso:\n"

#: main.c:740
#, c-format
msgid "  scanner options: -"
msgstr "  opciones del analizador: -"

# NFA significa non-deterministic finite automata, así que lo he traducido
# por AFN
#: main.c:819
#, c-format
msgid "  %d/%d NFA states\n"
msgstr "  %d/%d estados AFN\n"

# DFA significa deterministic finite autómata, lo he traducido por AFD
#: main.c:821
#, c-format
msgid "  %d/%d DFA states (%d words)\n"
msgstr "  %d/%d estados AFD {%d palabras}\n"

#: main.c:823
#, c-format
msgid "  %d rules\n"
msgstr "  %d reglas\n"

# Otra vez ;) em
# modificado como en la anterior ng
#: main.c:828
#, c-format
msgid "  No backing up\n"
msgstr "  Sin retroceso\n"

#: main.c:832
#, c-format
msgid "  %d backing-up (non-accepting) states\n"
msgstr "  %d estados de retroceso (no-aceptación)\n"

# FIXME.
# Informar al autor de que esta frase es casi idéntica a una anterior, para
# que sólo haya que traducirla una vez. sv
#: main.c:837
#, c-format
msgid "  Compressed tables always back-up\n"
msgstr "  Siempre se realiza copia de seguridad de las tablas comprimidas\n"

# Lo mismo "se han usado patrones de comienzo de línea". sv
#: main.c:841
#, c-format
msgid "  Beginning-of-line patterns used\n"
msgstr "  Usados patrones de comienzo-de-línea\n"

#: main.c:843
#, c-format
msgid "  %d/%d start conditions\n"
msgstr "  %d/%d condiciones de activación\n"

# Lo de estados épsilon lo entenderá un usuario avanzado, pero no sé si uno
# normal.
# Yo soy uno normal, y no sé lo que es em
# en teoría de autómatas no deterministas un estado épsilon es un estado
# en el que se puede realizar una transición no trivial sin leer nada,
# lo de doble épsilon no lo he oído nunca. Creo que hay que dejar el término
# técnico. ng
# Tu mandas, no tengo nada que decir a eso em
#: main.c:847
#, c-format
msgid "  %d epsilon states, %d double epsilon states\n"
msgstr "  %d estados épsilon, %d estados doble épsilon\n"

#: main.c:851
#, c-format
msgid "  no character classes\n"
msgstr "  sin clases de caracteres\n"

#: main.c:855
#, c-format
msgid "  %d/%d character classes needed %d/%d words of storage, %d reused\n"
msgstr ""
"  las clases de caracteres %d/%d necesitaron %d/%d palabras de\n"
"almacenamiento, %d reutilizadas\n"

# Frases como esta quedan algo sosas.
# ¿Qué tal "  se han creado %d pares estado/estado-siguiente"?
# Bueno, mejor no lo hagas hasta que no se sepa cómo queda al lado
# de las otras. sv
#: main.c:860
#, c-format
msgid "  %d state/nextstate pairs created\n"
msgstr "  %d pares estado/estado-siguiente creados\n"

# ## Añado sendas eses, ya que son transiciones. sv
#: main.c:863
#, c-format
msgid "  %d/%d unique/duplicate transitions\n"
msgstr "  %d/%d transiciones únicas/duplicadas\n"

# Entradas 'en' la tabla em
# sí, mejor ng
# ¿Que había antes? (¿entradas a la tabla?)
# (entradas *de* la tabla me suena mejor) sv.
#: main.c:868
#, c-format
msgid "  %d table entries\n"
msgstr "  %d entradas en la tabla\n"

# ## pongo `comillas' en el base-def. sv
#: main.c:876
#, c-format
msgid "  %d/%d base-def entries created\n"
msgstr "  %d/%d entradas `base-def' creadas\n"

#: main.c:880
#, c-format
msgid "  %d/%d (peak %d) nxt-chk entries created\n"
msgstr "  %d/%d (pico %d) entradas nxt-chk creadas\n"

#: main.c:884
#, c-format
msgid "  %d/%d (peak %d) template nxt-chk entries created\n"
msgstr "  %d/%d (pico %d) entradas de plantilla nxt-chk creadas\n"

# ¿entradas a la tabla o entradas de la tabla? sv
#: main.c:888
#, c-format
msgid "  %d empty table entries\n"
msgstr "  %d entradas en la tabla vacías\n"

#: main.c:890
#, c-format
msgid "  %d protos created\n"
msgstr "  %d prototipos creados\n"

#: main.c:893
#, c-format
msgid "  %d templates created, %d uses\n"
msgstr "  %d plantillas creadas, %d usos\n"

#: main.c:901
#, c-format
msgid "  %d/%d equivalence classes created\n"
msgstr "  %d/%d clases de equivalencia creadas\n"

# "se han creado..." sv
#: main.c:909
#, c-format
msgid "  %d/%d meta-equivalence classes created\n"
msgstr "  %d/%d clases de metaequivalencia creadas\n"

# A veces he visto traducir hash (o hashing) por desmenuzamiento, pero no
# me gusta
# demasiado. De todas formas es un término bastante usado sin traducir.
# A mí hash no me sugiere nada . Piensa en algo mejor, de momento lo dejo
# entre comillas em
# en cierto modo 'colisiones en la localización' sería una idea parecida
# quizás se pueda usar ng
# Me gusta más, pero ya te digo, soy un usuario de andar por casa, y sigo
# sin entender qué es em
# la idea del hash consiste en almacenar un registro (de cualquier tipo) en
# un lugar que se puede determinar mediante una transformación directa de su
# clave, por eso si hay dos claves iguales hay una colisión, porque dos
# registros van al mismo sitio ng+
#: main.c:915
#, c-format
msgid "  %d (%d saved) hash collisions, %d DFAs equal\n"
msgstr ""
"  %d (%d almacenadas) colisiones de localización ('hash'), %d AFDs iguales\n"

#: main.c:917
#, c-format
msgid "  %d sets of reallocations needed\n"
msgstr "  se necesitan %d conjuntos de relocalización\n"

# Lo mismo que en otro sitio: ¿table entries son entradas a la tabla o
# de la tabla? sv
#: main.c:919
#, c-format
msgid "  %d total table entries needed\n"
msgstr "  se necesitan %d entradas totales en la tabla\n"

#: main.c:996
#, c-format
msgid "Internal error. flexopts are malformed.\n"
msgstr "Error interno. flexopts mal formadas.\n"

#: main.c:1006
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: main.c:1063
#, c-format
msgid "unknown -C option '%c'"
msgstr "opción -C desconocida '%c'"

#: main.c:1192
#, c-format
msgid "%s %s\n"
msgstr "%s %s\n"

# Creo que no existe traducción de parse, en todo lo referente a compiladores
# y autómatas yo siempre lo he visto así.
# Existe alguna solución a 'parse', ¿qué tal
#  al analizar la sintaxis? em
# pero es que el parse es sólo una parte del analizador sintáctico
# aunque desde luego sería mucho más sencillo de entender el mensaje ng
# Habrá que plantearlo en el consejo de ancianos de Spanglish, que a veces
# resuelven mucho em
# ok, ¿cómo se le plantea? ng
# Sugerencia: error fatal. sv
# con comillas es un término medio. Lo de error grave fue una sugerencia
# de Enrique, y croe que queda mejor. ng+
#: main.c:1467
msgid "fatal parse error"
msgstr "error muy grave en el analizador sintáctico"

# Esto no tiene sentido. Uso flex a menudo, y no recuerdo haber visto
# este mensaje nunca. Pero no me parezca que tenga mucho sentido así
# em, ¿a qué se está refiriendo? em
# la verdad es que yo tampoco he usado esta opción, así que he aplicado la
# ley de Murphy, cuando todo lo demás falle, lea el manual. El archivo al
# que se refiere informa sobre todas las reglas que obligan a un retroceso
# del analizador, he rehecho el mensaje para que sea más claro ng
#
# Pues si este "backing" se refiere a un retroceso del analizador, los
# demás también, ¿no? (y no a "copias de seguridad"). sv
#
# ## Perfecto !, pero ten cuidado con los espacios despues del comienzo de línea
# ## , ejemplo
# ##
# ## msgstr " bla bla .. \n"
# ##    "bla bla ..."
# ##
# ## Eso no es válido ( solución, usa emacs po-mode :) ) em
# ## ok, ya estoy instalando linux otra vez ng+
#: main.c:1499
#, c-format
msgid "could not create backing-up info file %s"
msgstr ""
"no se pudo crear el archivo de información de las reglas\n"
"que producen un retroceso del analizador %s"

#: main.c:1520
#, c-format
msgid ""
"-l AT&T lex compatibility option entails a large performance penalty\n"
msgstr ""
"-l la opción de compatibilidad con AT&T lex implica una penalización del\n"
"rendimiento muy alta\n"

#: main.c:1523
#, c-format
msgid ""
" and may be the actual source of other reported performance penalties\n"
msgstr ""
" y puede ser el origen real de otras penalizaciones del rendimiento "
"notificadas\n"

#: main.c:1529
#, c-format
msgid ""
"%%option yylineno entails a performance penalty ONLY on rules that can match "
"newline characters\n"
msgstr ""
"la %%opción yylineno implica una penalización del rendimiento muy alta "
"SOLAMENTE en reglas que incluyan caracteres de salto de linea\n"

#: main.c:1536
#, c-format
msgid "-I (interactive) entails a minor performance penalty\n"
msgstr "-I (interactivo) implica una pequeña penalización del rendimiento\n"

#: main.c:1541
#, c-format
msgid "yymore() entails a minor performance penalty\n"
msgstr "yymore() implica un pequeña penalización del rendimiento\n"

#: main.c:1547
#, c-format
msgid "REJECT entails a large performance penalty\n"
msgstr "REJECT implica una penalización del rendimiento muy alta\n"

#: main.c:1552
#, c-format
msgid "Variable trailing context rules entail a large performance penalty\n"
msgstr ""
"La existencia de reglas de contexto posterior variable implica una\n"
"penalización del rendimiento muy alta\n"

#: main.c:1564
msgid "REJECT cannot be used with -f or -F"
msgstr "REJECT no se puede usar con -f o -F"

#: main.c:1567
#, c-format
msgid "%option yylineno cannot be used with REJECT"
msgstr "la %opción yylineno no se puede usar con REJECT"

#: main.c:1570
msgid "variable trailing context rules cannot be used with -f or -F"
msgstr ""
"las reglas de contexto posterior variable no se pueden usar con -f o -F"

#: main.c:1691
#, c-format
msgid "%option yyclass only meaningful for C++ scanners"
msgstr "la %option yyclass sólo tiene sentido para los analizadores en C++"

#: main.c:1798
#, c-format
msgid "Usage: %s [OPTIONS] [FILE]...\n"
msgstr "Uso: %s [OPCIONES] [FICHERO]...\n"

#: main.c:1801
#, c-format
msgid ""
"Generates programs that perform pattern-matching on text.\n"
"\n"
"Table Compression:\n"
"  -Ca, --align      trade off larger tables for better memory alignment\n"
"  -Ce, --ecs        construct equivalence classes\n"
"  -Cf               do not compress tables; use -f representation\n"
"  -CF               do not compress tables; use -F representation\n"
"  -Cm, --meta-ecs   construct meta-equivalence classes\n"
"  -Cr, --read       use read() instead of stdio for scanner input\n"
"  -f, --full        generate fast, large scanner. Same as -Cfr\n"
"  -F, --fast        use alternate table representation. Same as -CFr\n"
"  -Cem              default compression (same as --ecs --meta-ecs)\n"
"\n"
"Debugging:\n"
"  -d, --debug             enable debug mode in scanner\n"
"  -b, --backup            write backing-up information to %s\n"
"  -p, --perf-report       write performance report to stderr\n"
"  -s, --nodefault         suppress default rule to ECHO unmatched text\n"
"  -T, --trace             %s should run in trace mode\n"
"  -w, --nowarn            do not generate warnings\n"
"  -v, --verbose           write summary of scanner statistics to stdout\n"
"\n"
"Files:\n"
"  -o, --outfile=FILE      specify output filename\n"
"  -S, --skel=FILE         specify skeleton file\n"
"  -t, --stdout            write scanner on stdout instead of %s\n"
"      --yyclass=NAME      name of C++ class\n"
"      --header-file=FILE   create a C header file in addition to the "
"scanner\n"
"      --tables-file[=FILE] write tables to FILE\n"
"\n"
"Scanner behavior:\n"
"  -7, --7bit              generate 7-bit scanner\n"
"  -8, --8bit              generate 8-bit scanner\n"
"  -B, --batch             generate batch scanner (opposite of -I)\n"
"  -i, --case-insensitive  ignore case in patterns\n"
"  -l, --lex-compat        maximal compatibility with original lex\n"
"  -X, --posix-compat      maximal compatibility with POSIX lex\n"
"  -I, --interactive       generate interactive scanner (opposite of -B)\n"
"      --yylineno          track line count in yylineno\n"
"\n"
"Generated code:\n"
"  -+,  --c++               generate C++ scanner class\n"
"  -Dmacro[=defn]           #define macro defn  (default defn is '1')\n"
"  -L,  --noline            suppress #line directives in scanner\n"
"  -P,  --prefix=STRING     use STRING as prefix instead of \"yy\"\n"
"  -R,  --reentrant         generate a reentrant C scanner\n"
"       --bison-bridge      scanner for bison pure parser.\n"
"       --bison-locations   include yylloc support.\n"
"       --stdinit           initialize yyin/yyout to stdin/stdout\n"
"       --noansi-definitions old-style function definitions\n"
"       --noansi-prototypes  empty parameter list in prototypes\n"
"       --nounistd          do not include <unistd.h>\n"
"       --noFUNCTION        do not generate a particular FUNCTION\n"
"\n"
"Miscellaneous:\n"
"  -c                      do-nothing POSIX option\n"
"  -n                      do-nothing POSIX option\n"
"  -?\n"
"  -h, --help              produce this help message\n"
"  -V, --version           report %s version\n"
msgstr ""
"Genera programas que realizan emparejado de patrones en texto.\n"
"\n"
"Compresión de tablas: (por defecto es -Cem)\n"
"  -Ca, --align      Renuncia a tablas grandes para mejorar la alineación en "
"memoria\n"
"  -Ce, --ecs        construye clases de equivalencia\n"
"  -Cf               no comprime las tablas; utiliza la representación -f\n"
"  -CF               no comprime las tablas; utiliza la representación -F\n"
"  -Cm, --meta-ecs   construye clases de metaequivalencia\n"
"  -Cr, --read       utiliza read() en lugar de stdio para la entrada del "
"analizador\n"
"  -f, --full        genera una analizar rápido y grande. Igual que -Cfr\n"
"  -F, --fast        usa la representación de tablas alternativa. Igual que -"
"CFr\n"
"  -Cem              compresión por defecto (igual que --ecs --meta-ecs)\n"
"\n"
"Depurado:\n"
"  -d, --debug             activa el modo de depuración en el analizador\n"
"  -b, --backup            escribe información de seguridad en %s\n"
"  -p, --perf-report       escribe un informe de rendimiento en stderr\n"
"  -s, --nodefault         suprime la regla por defecto consistente en un "
"ECHO de cualquier carácter sin emparejar\n"
"  -T, --trace             %s debería ejecutarse en modo traza\n"
"  -w, --nowarn            no genera avisos\n"
"  -v, --verbose           escribe un resumen de estadísticas del analizador "
"en stdout\n"
"\n"
"Ficheros:\n"
"  -o, --outfile=FILE      especifica el nombre del fichero de salida\n"
"  -S, --skel=FILE         especifica el archivo de esquema\n"
"  -t, --stdout            escribe el analizador en stdout en lugar de en %s\n"
"      --yyclass=NAME      nombre de la clase de C++\n"
"      --header=FILE       crea un archivo de cabecera de C además del "
"analizador\n"
"\n"
"Comportamiento del analizador:\n"
"  -7, --7bit              genera un analizador de 7 bits\n"
"  -8, --8bit              genera un analizador de 8 bits\n"
"  -B, --batch             genera un analizador en modo batch (opuesto a -I)\n"
"  -i, --case-insensitive  ignora mayúsculas y minúsculas en los patrones\n"
"  -l, --lex-compat        compatibilidad máxima con lex\n"
"  -I, --interactive       genera un analizador interactivo (opuesto a -B)\n"
"      --yylineno          mantiene información del conteo de líneas en "
"yylineno\n"
"\n"
"Código generado:\n"
"  -+,  --c++               genera una clase C++ con el analizador\n"
"  -Dmacro[=defn]           #define macro defn  (pro defecto defn es '1')\n"
"  -L,  --noline            suprime las directivas #line en el analizador\n"
"  -P,  --prefix=STRING     usa STRING como prefijo en lugar de \"yy\"\n"
"  -R,  --reentrant         generate un analizador C reentrante\n"
"  -Rb, --reentrant-bison   analizador reentrante para un analizador léxico "
"bison puro.\n"
"       --stdinit           inicializa yyin/yyout a stdin/stdout\n"
"       --noFUNCTION        no genera la función FUNCTION\n"
"\n"
"Miscelánea:\n"
"  -c                      opción POSIX do-nothing\n"
"  -n                      opción POSIX do-nothing\n"
"  -?\n"
"  -h, --help              produce este mensaje de ayuda\n"
"  -V, --version           informa de la versión %s\n"

#: misc.c:100 misc.c:126
#, c-format
msgid "name \"%s\" ridiculously long"
msgstr "nombre \"%s\" ridículamente grande"

#  Asignación de memoria  em
# ¿está unificado? ng
# Sí, pero creo que sólo por mí. Normalmente esos mensajes
# los dá la biblioteca C antes em
# ok ng+
#: misc.c:175
msgid "memory allocation failed in allocate_array()"
msgstr "falló la asignación de memoria en `allocate_array()'"

#: misc.c:250
#, c-format
msgid "bad character '%s' detected in check_char()"
msgstr "carácter incorrecto '%s' detectado en `check_char()'"

# he añadido el `poder' em
# ok ng
#: misc.c:255
#, c-format
msgid "scanner requires -8 flag to use the character %s"
msgstr "el analizador requiere la opción -8 para poder usar el carácter %s"

#: misc.c:288
msgid "dynamic memory failure in copy_string()"
msgstr "fallo de la memoria dinámica en copy_string()"

# Sugerencia: error fatal. sv
#: misc.c:422
#, c-format
msgid "%s: fatal internal error, %s\n"
msgstr "%s: error interno muy grave, %s\n"

#: misc.c:875
msgid "attempt to increase array size failed"
msgstr "falló el intento de aumentar el tamaño de la matriz"

#: misc.c:1002
msgid "bad line in skeleton file"
msgstr "línea incorrecta en el archivo de esquema"

#: misc.c:1051
msgid "memory allocation failed in yy_flex_xmalloc()"
msgstr "la reserva de memoria falló en yy_flex_xmalloc()"

#: nfa.c:104
#, c-format
msgid ""
"\n"
"\n"
"********** beginning dump of nfa with start state %d\n"
msgstr ""
"\n"
"\n"
"********** comenzando la descarga del AFN con el estado inicial %d\n"

#: nfa.c:115
#, c-format
msgid "state # %4d\t"
msgstr "estado # %4d\t"

# Sugerencia: volcado. sv
# ok ng+
#: nfa.c:130
#, c-format
msgid "********** end of dump\n"
msgstr "********** fin de volcado\n"

#: nfa.c:174
msgid "empty machine in dupmachine()"
msgstr "máquina vacía en `dupmachine()'"

#: nfa.c:240
#, c-format
msgid "Variable trailing context rule at line %d\n"
msgstr "Regla de contexto posterior variable en la línea %d\n"

#: nfa.c:353
msgid "bad state type in mark_beginning_as_normal()"
msgstr "tipo de estado incorrecto en mark_beginning_as_normal()"

#: nfa.c:598
#, c-format
msgid "input rules are too complicated (>= %d NFA states)"
msgstr "las reglas de entrada son demasiado complicadas (>= %d estados AFN)"

# Sugerencia: se han encontrado... sv
#: nfa.c:677
msgid "found too many transitions in mkxtion()"
msgstr "encontradas demasiadas transiciones en mkxtion()"

#: nfa.c:703
#, c-format
msgid "too many rules (> %d)!"
msgstr "demasiadas reglas (> %d)!"

#: parse.y:159
msgid "unknown error processing section 1"
msgstr "error desconocido en el proceso de la sección 1"

#: parse.y:184 parse.y:351
msgid "bad start condition list"
msgstr "lista de condiciones de activación incorrecta"

#: parse.y:315
msgid "unrecognized rule"
msgstr "regla no reconocida"

#: parse.y:434 parse.y:447 parse.y:516
msgid "trailing context used twice"
msgstr "contexto posterior usado dos veces"

#: parse.y:552 parse.y:562 parse.y:635 parse.y:645
msgid "bad iteration values"
msgstr "valores incorrectos para iteración"

#: parse.y:580 parse.y:598 parse.y:663 parse.y:681
msgid "iteration value must be positive"
msgstr "los valores para iteración deben ser positivos"

#: parse.y:806 parse.y:816
#, c-format
msgid ""
"the character range [%c-%c] is ambiguous in a case-insensitive scanner"
msgstr ""
"el intervalo de carácteres [%c-%c] es ambiguo en un analizador que no "
"distingue entre mayúsculas y minúsculas"

#: parse.y:821
msgid "negative range in character class"
msgstr "rango negativo en clase caracteres"

#: parse.y:918
msgid "[:^lower:] is ambiguous in case insensitive scanner"
msgstr ""
"[:^lower:] es ambiguo en un analizador que no distingue mayúsculas y "
"minúsculas"

#: parse.y:924
msgid "[:^upper:] ambiguous in case insensitive scanner"
msgstr ""
"[:^upper:] es ambiguo en un analizador que no distingue mayúsculas y "
"minúsculas"

#: scan.l:75 scan.l:192 scan.l:300 scan.l:443 scan.l:618 scan.l:676
msgid "Input line too long\n"
msgstr "Línea de entrada demasiado larga\n"

#: scan.l:161
#, c-format
msgid "malformed '%top' directive"
msgstr "directiva '%top' mal formada"

#: scan.l:183
#, no-c-format
msgid "unrecognized '%' directive"
msgstr "directiva '%' no reconocida"

#: scan.l:284
msgid "Unmatched '{'"
msgstr "Un '{' sin cerrar"

#: scan.l:317
msgid "incomplete name definition"
msgstr "definición de nombre incompleta"

#: scan.l:451
#, c-format
msgid "unrecognized %%option: %s"
msgstr "%%opción no reconocida: %s"

#: scan.l:633 scan.l:800
msgid "bad character class"
msgstr "clase de caracteres incorrecta"

#: scan.l:683
#, c-format
msgid "undefined definition {%s}"
msgstr "definición no definida {%s}"

#: scan.l:755
#, c-format
msgid "bad <start condition>: %s"
msgstr "<condición de activación> incorrecta: %s"

# Sugerencia: falta una comilla. sv
#: scan.l:768
msgid "missing quote"
msgstr "falta comilla"

# Corregido el orden de la frase, ponía:
# incorrecta la expresión ... em
# ok, de traducir al final ocurre que acabas hablando al revés,
# como en inglés ng
#: scan.l:834
#, c-format
msgid "bad character class expression: %s"
msgstr "expresión de la clase de caracteres incorrecta: %s"

#: scan.l:856
msgid "bad character inside {}'s"
msgstr "carácter incorrecto dentro de {}'s"

# Sugerencia: "falta una }". sv
#: scan.l:862
msgid "missing }"
msgstr "falta }"

#: scan.l:940
msgid "EOF encountered inside an action"
msgstr "Fin de archivo (EOF) encontrado dentro de una acción"

#: scan.l:945
msgid "EOF encountered inside pattern"
msgstr "Fin de archivo (EOF) encontrado en un patrón"

#: scan.l:967
#, c-format
msgid "bad character: %s"
msgstr "carácter incorrecto: %s"

#: scan.l:996
#, c-format
msgid "can't open %s"
msgstr "no se puede abrir %s"

#: scanopt.c:291
#, c-format
msgid "Usage: %s [OPTIONS]...\n"
msgstr "Uso: %s [OPCIONES]...\n"

#: scanopt.c:565
#, c-format
msgid "option `%s' doesn't allow an argument\n"
msgstr "la opción `%s'  no permite un argumento\n"

#: scanopt.c:570
#, c-format
msgid "option `%s' requires an argument\n"
msgstr "la opción `%s'  requiere un argumento\n"

#: scanopt.c:574
#, c-format
msgid "option `%s' is ambiguous\n"
msgstr "la opción `%s' es ambigua\n"

#: scanopt.c:578
#, c-format
msgid "Unrecognized option `%s'\n"
msgstr "Opción no reconocida `%s'\n"

#: scanopt.c:582
#, c-format
msgid "Unknown error=(%d)\n"
msgstr "Error desconocido=(%d)\n"

# Asignación de memoria em
#: sym.c:100
msgid "symbol table memory allocation failed"
msgstr "falló la reserva de memoria para la tabla de símbolos"

# hay que procurar evitar esto, siempre nos suena mejor
# el nombre ha sido definido dos veces, ¿qué te parece? em
# mucho mejor, ya lo había pensado, pero no sabía cual era el estilo usual. ng
#: sym.c:202
msgid "name defined twice"
msgstr "el nombre ha sido definido dos veces"

# Aquí lo mismo 'la condición ... ha sido ..." em
#: sym.c:253
#, c-format
msgid "start condition %s declared twice"
msgstr "la condición de activación %s ha sido declarada dos veces"

#: yylex.c:56
msgid "premature EOF"
msgstr "fin de archivo (EOF) prematuro"

#: yylex.c:198
#, c-format
msgid "End Marker\n"
msgstr "Marcador de fin\n"

# sobre lo de tok, me parece que es abreviatura de token. ng
# en bison he traducido token por terminal, creo que es bueno unificar. ng
#: yylex.c:204
#, c-format
msgid "*Something Weird* - tok: %d val: %d\n"
msgstr "*Algo extraño* - terminal: %d val: %d\n"
