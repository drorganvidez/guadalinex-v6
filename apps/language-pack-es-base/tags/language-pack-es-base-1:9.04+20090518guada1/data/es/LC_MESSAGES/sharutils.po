# Mensajes en español para GNU sharutils.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Tomás Bautista <bautista@cma.ulpgc.es>, 1996.
# Santiago Vila <sanvila@unex.es>, 2006.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU sharutils 4.6.3-pre4\n"
"Report-Msgid-Bugs-To: bug-gnu-utils@gnu.org\n"
"POT-Creation-Date: 2006-06-03 12:18-0700\n"
"PO-Revision-Date: 2007-06-11 08:11+0000\n"
"Last-Translator: Daniel Fuertes Pérez (DaniFP) <danifp25@yahoo.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Launchpad-Export-Date: 2009-04-10 22:10+0000\n"
"X-Generator: Launchpad (build Unknown)\n"

#: lib/error.c:131 lib/error.c:159
msgid "Unknown system error"
msgstr "Error del sistema desconocido"

#: lib/getopt.c:694
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: lib/getopt.c:719
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `%s' no permite ningún argumento\n"

#: lib/getopt.c:724
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no permite ningún argumento\n"

#: lib/getopt.c:742 lib/getopt.c:915
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' requiere un argumento\n"

#: lib/getopt.c:771
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción no reconocida `--%s'\n"

#: lib/getopt.c:775
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción no reconocida `%c%s'\n"

#: lib/getopt.c:801
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: lib/getopt.c:804
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción inválida -- %c\n"

#: lib/getopt.c:834 lib/getopt.c:964
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: lib/getopt.c:881
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: lib/getopt.c:899
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite ningún argumento\n"

#: lib/xmalloc.c:66
msgid "memory exhausted"
msgstr "memoria agotada"

#: src/shar.c:606
msgid "Note: not verifying md5sums.  Consider installing GNU coreutils."
msgstr ""
"Nota: no se verifican las sumas md5. Considere instalar GNU coreutils."

# Nota: Se supone que este mensaje continúa en el siguiente. De ahí el "e".
#
# FIXME: No se traducen palabras sueltas sino frases completas.
# Hablar con el autor.
#: src/shar.c:641
msgid "WARNING: not restoring timestamps.  Consider getting and"
msgstr ""
"ATENCIÓN: no se restablecerán las marcas de tiempo.\n"
"  Considere tomar e"

#: src/shar.c:643
msgid "installing GNU `touch'\\'', distributed in GNU coreutils..."
msgstr "instalar GNU `touch'\\'', distribuido con GNU coreutils..."

#: src/shar.c:650
msgid "lock directory '${lock_dir}' exists"
msgstr "el directorio de bloqueo '${lock_dir}' existe"

#: src/shar.c:655
msgid "failed to create lock directory"
msgstr "fallo al crear el directorio de bloqueo"

#: src/shar.c:659
#, c-format
msgid "x - created lock directory `'%s\\''."
msgstr "x - creado el directorio de bloqueo `'%s\\''."

#: src/shar.c:661
#, c-format
msgid "x - failed to create lock directory `'%s\\''."
msgstr "x - fallo al crear el directorio de bloqueo `'%s\\''."

#: src/shar.c:669
msgid "yes"
msgstr "sí"

#: src/shar.c:669
msgid "overwrite this file"
msgstr "sobrescribe este fichero"

#: src/shar.c:670
msgid "no"
msgstr "no"

#: src/shar.c:670
msgid "skip this file"
msgstr "salta este fichero"

#: src/shar.c:671
msgid "all"
msgstr "todos"

#: src/shar.c:671
msgid "overwrite all files"
msgstr "sobrescribe todos los ficheros"

#: src/shar.c:672
msgid "none"
msgstr "ninguno"

#: src/shar.c:672
msgid "overwrite no files"
msgstr "no sobrescribe ningún fichero"

#: src/shar.c:673
msgid "help"
msgstr "ayuda"

#: src/shar.c:673
msgid "explain choices"
msgstr "explica las opciones"

#: src/shar.c:674
msgid "quit"
msgstr "salir"

#: src/shar.c:674
msgid "exit immediately"
msgstr "sale inmediatamente"

#: src/shar.c:716
msgid "Too many directories for mkdir generation"
msgstr "Demasiados directorios para crear con `mkdir'"

#: src/shar.c:735
#, c-format
msgid "x - created directory `%s'\\''."
msgstr "x - creado el directorio `%s'\\''."

#: src/shar.c:737
#, c-format
msgid "x - failed to create directory `%s'\\''."
msgstr "x - fallo al crear el directorio `%s'\\''."

#: src/shar.c:804 src/shar.c:1055
#, c-format
msgid "Cannot access %s"
msgstr "No se puede acceder a %s"

#: src/shar.c:858
msgid "-C is being deprecated, use -Z instead"
msgstr "La opción -C está obsoleta, utilice -Z en su lugar"

#: src/shar.c:899 src/unshar.c:377
msgid "Cannot get current directory name"
msgstr "No se puede recibir el nombre del directorio actual"

#: src/shar.c:963
msgid ""
"Archives must be unpacked in sequence!\n"
"Please unpack part '`cat ${lock_dir}/seq`' next."
msgstr ""
"¡Los archivos deben desempaquetarse en orden!\n"
"Por favor desempaquete '`cat ${lock_dir}/seq`' a continuación."

#: src/shar.c:974 src/shar.c:1381
#, c-format
msgid "New file, remaining %s, "
msgstr "Nuevo fichero, faltan %s, "

#: src/shar.c:975 src/shar.c:1382
#, c-format
msgid "Limit still %s\n"
msgstr "El límite es aún %s\n"

#: src/shar.c:981 src/shar.c:1556 src/shar.c:1572
#, c-format
msgid "restore of %s failed"
msgstr "la restauración de %s falló"

#: src/shar.c:985
#, c-format
msgid "End of part %d, continue with part %d"
msgstr "Fin de la parte %d, continúa con la parte %d"

#: src/shar.c:999 src/shar.c:1475
#, c-format
msgid "Starting file %s\n"
msgstr "Iniciando el fichero %s\n"

#: src/shar.c:1050
#, c-format
msgid "%s: Not a regular file"
msgstr "%s: No es un fichero regular"

# Me resulta demasiado inconexo ... ¿y poner algo así como
# `quedan %ld bytes' aunque no sea tan fiel como debiera?
# ipg
# A mí no me disgusta. Pero pongo "faltan" en vez de "quedan". tb
#: src/shar.c:1065
#, c-format
msgid "In shar: remaining size %s\n"
msgstr "En `shar': faltan %s bytes\n"

#: src/shar.c:1084
msgid "empty"
msgstr "vacío"

#: src/shar.c:1085
msgid "(empty)"
msgstr "(vacío)"

#: src/shar.c:1109
#, c-format
msgid "Cannot open file %s"
msgstr "No se puede abrir el archivo %s"

# Para que esto "haga juego" con otra cosa que hay más abajo, quizá habría
# que poner "comprimido con `compress'", ¡qué horror! sv
# Sí, ya sé que es un poco raro, pero, ¿qué otra cosa se podría hacer? tb
# Nada, creo. O esto, o lo que había antes. sv
# Bueno, la verdad es que así se respeta fielmente el original, pues
# lo que se traducen no son palabras sino significados. sv
#: src/shar.c:1146
msgid "compressed"
msgstr "comprimido"

#: src/shar.c:1147
msgid "gzipped"
msgstr "comprimido con gzip"

#: src/shar.c:1148
msgid "bzipped"
msgstr "comprimido con bzip"

#: src/shar.c:1149
msgid "binary"
msgstr "binario"

#: src/shar.c:1150
msgid "(compressed)"
msgstr "(comprimido)"

#: src/shar.c:1151
msgid "(gzipped)"
msgstr "(comprimido con gzip)"

#: src/shar.c:1152
msgid "(bzipped)"
msgstr "(comprimido con bzip)"

#: src/shar.c:1153
msgid "(binary)"
msgstr "(binario)"

# Votaría por alguna descripción más amplia -- siempre doy la coña
# con esta frase:
# `No se pudo duplicar el proceso (falló la llamada a fork())'
# ipg
# O me equivoco, o hacer un fork no es duplicar un proceso, sino que crea
# un nuevo proceso:
#
# FORK(2V)                  SYSTEM CALLS                   FORK(2V)
#
# NAME
#      fork - create a new process
#
# Por lo tanto voy a escribir otra cosa. tb
#
# Te ha faltado citar esto de la misma página de manual:
#
# DESCRIPTION
#        fork  creates a child process that differs from the parent
#        process only in its PID and PPID, and  in  the  fact  that
#        resource  utilizations are set to 0.  File locks and pend­
#        ing signals are not inherited.
#
# fork() realmente lo único que hace es copiar las tablas de datos del
# núcleo del padre y los segmentos de datos del padre, por lo que lo
# único en lo que difieren justo después de la llamada a fork() es en el
# PID, en los locks y en las señales en espera de servicio. A eso se le
# llama duplicar un proceso. Que luego se use para crear un proceso
# nuevo con exec() es harina de otro costal, pero la única manera de
# crear más procesos en Unix es pasar por duplicar primero un proceso.
#
# También es verdad que al usuario qué gracia le hará la diferencia,
# pero no debemos confundir los huevos con las castañas, y al menos,
# intentar que la gente lo comprenda. ipg
#
#
# Esto lo discutí con Iñaky y Jim Meyering y al final les convencí :-)
# Lo cambio. sv
# Para la poteridá: Antes decía:
# "No se pudo crear un proceso nuevo: fallo en la llamada a `fork'"
# Pues lo dejamos cambiado. tb
#
# FIXME: Escribir al autor, de todas formas. sv+
#: src/shar.c:1166
msgid "Could not fork"
msgstr "No se pudo crear otro proceso"

#: src/shar.c:1171 src/shar.c:1231
#, c-format
msgid "File %s (%s)"
msgstr "Fichero %s (%s)"

#: src/shar.c:1225
msgid "text"
msgstr "texto"

#: src/shar.c:1226
msgid "(text)"
msgstr "(texto)"

# He quitado una 'e' em+
#: src/shar.c:1249
#, c-format
msgid "overwriting %s"
msgstr "sobrescribiendo %s"

#: src/shar.c:1251
#, c-format
msgid "overwrite %s"
msgstr "sobrescribe %s"

# Estamos empleando extensivamente: 'pasando por alto' em+
# Bueno, eres tú quien lo está empleando extensivamente.
# Iñaky utiliza descartar, y yo depende del caso.
#
# Análisis semántico:
# Literalmente, skip es saltar, y quiere decir que no se considera.
# Pasar por alto, parece que sí se considera pero luego se hace la vista
# gorda, o algo así (como un "perdón").
# Tal vez por eso no me acabe de gustar "pasar por alto". sv+
#: src/shar.c:1255
#, c-format
msgid "SKIPPING %s"
msgstr "SALTANDO %s"

# interrumpida ?  sv
# Interrumpir y abortar, aunque son cosas similares,
# normalmente dan lugar a resultados distintos.
#: src/shar.c:1256
msgid "extraction aborted"
msgstr "extracción interrumpida"

#: src/shar.c:1260
#, c-format
msgid "SKIPPING %s (file already exists)"
msgstr "SALTANDO %s (el fichero ya existe)"

#: src/shar.c:1270
#, c-format
msgid "Saving %s (%s)"
msgstr "Guardando %s (%s)"

#: src/shar.c:1274
#, c-format
msgid "x - extracting %s %s"
msgstr "x - extrayendo< %s %s"

#: src/shar.c:1390
#, c-format
msgid "restore of %s failed\n"
msgstr "la restauración de %s falló\n"

#: src/shar.c:1399
#, c-format
msgid "End of part %ld, continue with part %ld"
msgstr "Fin de la parte %ld, continúa con la parte %ld"

# Nota: se supone que después de este mensaje aparece un numerito.
#: src/shar.c:1405
#, c-format
msgid "End of %s part %d"
msgstr "Fin de %s parte %d"

#: src/shar.c:1406
msgid "archive"
msgstr "archivo"

#: src/shar.c:1410
#, c-format
msgid "File %s is continued in part %d"
msgstr "El fichero %s continúa en la parte %d"

#: src/shar.c:1454
msgid "Please unpack part 1 first!"
msgstr "¡Por favor, desempaquete primero la parte 1!"

#: src/shar.c:1458
msgid "Please unpack part '${shar_sequence}' next!"
msgstr "¡Por favor, desempaquete la parte '${shar_sequence}' a continuación!"

# Idem em+
#: src/shar.c:1469
#, c-format
msgid "STILL SKIPPING %s"
msgstr "TODAVÍA SALTANDO %s"

#: src/shar.c:1477
#, c-format
msgid "continuing file %s"
msgstr "continuando con el fichero %s"

#: src/shar.c:1495
#, c-format
msgid "File %s is complete"
msgstr "El fichero %s se ha completado"

# Otra sugerencia: descodificando en lugar de decodificando. sv
# Y otra más: descodificando el archivo ... (añadir "el"). sv
# Ya... bueno. Por aquí solemos usar decodificar, en vez de descodificar,
# pero no sé cual es lo correcto. ¿Y qué tal descifrar? tb
#
# Me suena a criptografía (es decir, da a entender
# que está codificado de alguna manera extraña,
# cuando en realidad el "uuencode" es muy sencillo). sv
# ¿Entonces "descodificar"? Advierto que va a haber gente extrañada en
# este punto. Por ejemplo, yo. tb
#
# El Unix es bello .... :) ipg
#
# Una cosa: ¿decodificar o descodificar?
# (es que me suena mejor lo segundo) sv
#
# Para el Canal Plus ¿qué se usa? ¿un descodificador o un decodificador?
# Pregúntese a quien tenga uno, y entonces decidimos. tb
# :-) :-) :-) sv
#: src/shar.c:1502
#, c-format
msgid "uudecoding file %s"
msgstr "decodificando el fichero %s con `uudecode'"

# Nota: Añadir "con `uncompress'" está justificado por el hecho de que
# cuando se descomprime con gunzip se le llama "gunzipping".
#: src/shar.c:1512
#, c-format
msgid "uncompressing file %s"
msgstr "descomprimiendo el fichero %s con `uncompress'"

#: src/shar.c:1520
#, c-format
msgid "gunzipping file %s"
msgstr "descomprimiendo el fichero %s con `gunzip'"

#: src/shar.c:1528
#, c-format
msgid "bunzipping file %s"
msgstr "descomprimiendo el fichero %s con `bunzip'"

# Sugerencia: "suma de comprobación MD5" o "comprobación MD5". sv
# El "check" es el mismo "check" de "cheksum" (suma de comprobación), solo que
# MD5 no hace propiamente una suma sino un "revoltijo" con una
# función de `hash'. sv
# Los alemanes usan para esto `test.' Y a mí es una palabra que no me gusta,
# pero... tb
# Para MD5 he oído más los términos `huella digital MD5', `huella MD5'
# o `firma MD5'. ipg
# Pues si eso es lo que por ahí se oye, pues p'alante. tbd
# Si lo pones así, quizá quedaría mejor `Comprobación de la huella
# digital ...' y yo añadiría algo de `Es probable que el archivo esté
# jodido', pero más educadamente. ipg
# Hecho. tb
#
# Borro lo del fichero dañado. No es NADA fiel al original.
# Si el original hubiera querido decir algo acerca de un fichero dañado
# lo habría dicho. Además, puede que el fichero no esté dañado, sino
# que simplemente esté falsificado o sea otra versión.
#
# Propongo "Fallo en la suma MD5". Más fácil, más corto, más bonito...
# No importa que no sea exactamente una suma, puede considerarse una
# "suma generalizada". Además, el programa que genera eso se llama
# `md5sum' (es decir, parecido a "cheksum", y con la misma función aunque
# utilice un algoritmo distinto). sv
#
# No es la suma MD5 la que falla sino la comprobación, ¿no? tb
# Bueno, también puede decirse que es la suma la que falla, en tanto que no
# es la que debería ser. Déjalo como está, si te parece. sv
#: src/shar.c:1583
msgid "MD5 check failed"
msgstr "Falló la comprobación MD5"

#: src/shar.c:1639
#, c-format
msgid "'restoration warning:  size of %s is not %s'\n"
msgstr "'aviso de restauración: el tamaño de %s no es %s'\n"

#: src/shar.c:1691
msgid "allocating output file name"
msgstr "reserva de espacio para el nombre del fichero de salida"

#: src/shar.c:1697
#, c-format
msgid "Opening `%s'"
msgstr "Abriendo `%s'"

#: src/shar.c:1708
#, c-format
msgid "Closing `%s'"
msgstr "Cerrando `%s'"

#: src/shar.c:1720 src/unshar.c:313 src/uudecode.c:439 src/uuencode.c:204
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Ejecute `%s --help' para más información.\n"

#: src/shar.c:1724 src/unshar.c:317
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Uso: %s [OPCIÓN]... [FICHERO]...\n"

#: src/shar.c:1725
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas son también "
"obligatorios\n"
"para las opciones cortas.\n"

#: src/shar.c:1728
msgid ""
"\n"
"Giving feedback:\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"  -q, --quiet, --silent   do not output verbose messages locally\n"
msgstr ""
"\n"
"Opciones de realimentación:\n"
"      --help            muestra esta ayuda y finaliza\n"
"      --version         informa de la versión y finaliza\n"
"  -q, --quiet, --silent  no muestra mensajes de progreso localmente\n"

#: src/shar.c:1736
msgid ""
"\n"
"Selecting files:\n"
"  -p, --intermix-type     allow -[BTzZ] in file lists to change mode\n"
"  -S, --stdin-file-list   read file list from standard input\n"
msgstr ""
"\n"
"Selección de ficheros:\n"
"  -p  --intermix-type      permite -[BTzZ] en listas de ficheros para "
"cambiar\n"
"                           el modo\n"
"  -S, --stdin-file-list    lee la lista de ficheros de la entrada estándar\n"

#: src/shar.c:1743
msgid ""
"\n"
"Selecting files:\n"
"  -p, --intermix-type     allow -[BTz] in file lists to change mode\n"
"  -S, --stdin-file-list   read file list from standard input\n"
msgstr ""
"\n"
"Selección de ficheros:\n"
"\n"
"  -p, --intermix-type     permite -[BTz] en listas de ficheros para cambiar "
"el\n"
"                          modo\n"
"  -S, --stdin-file-list   lee la lista de ficheros de la entrada estándar\n"

#: src/shar.c:1750
msgid ""
"\n"
"Splitting output:\n"
"  -o, --output-prefix=PREFIX    output to file PREFIX.01 through PREFIX.NN\n"
"  -l, --whole-size-limit=SIZE   split archive, not files, to SIZE kilobytes\n"
"  -L, --split-size-limit=SIZE   split archive, or files, to SIZE kilobytes\n"
msgstr ""
"\n"
"División del resultado:\n"
"  -o, --output-prefix=PREFIJO    coloca el resultado en PREFIJO.01 a "
"PREFIJO.NN\n"
"  -l, --whole-size-limit=TAMAÑO  divide el archivo, no los ficheros, en "
"trozos\n"
"                                 de TAMAÑO kilobytes\n"
"  -L, --split-size-limit=TAMAÑO  divide el archivo, o los ficheros, en "
"trozos\n"
"                                 de TAMAÑO kilobytes\n"

# Otra cosa: El "controlling" y el "selecting" creo que no son gerundios.
# Diría que aquí lo que pega es:
# "Control de las cabeceras del archivo shar"
# "Selección de cómo se almacenan los archivos".
# ¿qué opinas? sv
#
# Nota: No hace falta poner sangría adicional cuando una opción te ocupe
# más de una línea. Solemos dejarlo al mismo nivel.
# (He cambiado tan sólo el "línea de corte", si estás de acuerdo, puedes
# hacerlo tú con los demás). sv
# ¿Coding -> cifrado? tb
# En -a ¿documentar? me suena un rato dao la vuerta :) ipg
# Vale. tb
#: src/shar.c:1757
msgid ""
"\n"
"Controlling the shar headers:\n"
"  -n, --archive-name=NAME   use NAME to document the archive\n"
"  -s, --submitter=ADDRESS   override the submitter name\n"
"  -a, --net-headers         output Submitted-by: & Archive-name: headers\n"
"  -c, --cut-mark            start the shar with a cut line\n"
"  -t, --translate           translate messages in the script\n"
"\n"
"Selecting how files are stocked:\n"
"  -M, --mixed-uuencode         dynamically decide uuencoding (default)\n"
"  -T, --text-files             treat all files as text\n"
"  -B, --uuencode               treat all files as binary, use uuencode\n"
"  -z, --gzip                   gzip and uuencode all files\n"
"  -g, --level-for-gzip=LEVEL   pass -LEVEL (default 9) to gzip\n"
"  -j, --bzip2                  bzip2 and uuencode all files\n"
msgstr ""
"\n"
"Control de las cabeceras de archivo `shar':\n"
"  -n, --archive-name=NOMBRE   usa NOMBRE para documentar el archivo\n"
"  -s, --submitter=DIRECCIÓN   ignora el nombre del remitente\n"
"  -a, --net-headers           documenta el archivo `shar' con cabeceras\n"
"                              de tipo `Submitted-by:' y `Archive-name:'\n"
"  -c, --cut-mark              comienza el archivo `shar' con una\n"
"                              línea de corte\n"
"  -t, --translate             traduce los mensajes del script\n"
"\n"
"Selección del modo de almacenamiento de los archivos:\n"
"  -M, --mixed-uuencode        decide automáticamente el cifrado con\n"
"                              `uuencode' (por defecto)\n"
"  -T, --text-files            trata todos los archivos como texto\n"
"  -B, --uuencode              trata todos los archivos como datos \n"
"                              binarios, utilizando `uuencode'\n"
"  -z, --gzip                  procesa todos los archivos con `gzip' y\n"
"                              `uuencode'\n"
"  -g, --level-for-gzip=NIVEL  pasa -NIVEL (por defecto 9) a `gzip'\n"
"  -j, --bzip2                 procesa todos los ficheros con bzip2\n"
"                              y uuencode\n"

#: src/shar.c:1775
msgid ""
"  -Z, --compress               compress and uuencode all files\n"
"  -b, --bits-per-code=BITS     pass -bBITS (default 12) to compress\n"
msgstr ""
"  -Z, --compress               comprime y codifica con uuencode todos los\n"
"                               ficheros\n"
"  -b, --bits-per-code=BITS     pasa -bBITS (por omisión 12) a compress\n"

# En -D, ¿qué tal `no comprueba la huella MD5 con `md5sum'' (donde
# digo `huella' pon lo que más te guste :)?
# En -V ¿`no exigente' -> `poco exigente'?
# En -Q ¿`actúa silenciosamente al ...'?
# Yo no traduciría `script' a `guión' ... me ha costado un rato darme
# cuenta de que querías decir (mente lúcida la mía que ha tardado en
# mirar la versión inglesa :). En todos sitios lo hemos dejado como
# script, pero entre comillas simples. Poca gente usa la palabra
# `guión' para referirse a un shell script.
# En -X `no para red' -> `no usar en Usenet o redes públicas'
# ipg
# Dejo algunas cosas como estaban (-Q) y otras las cambio. Lo de `guión',
# de acuerdo en dejarlo en `script' (me guiaba por algo que se discutió
# en la lista de spanglish). tb
#
# Lo de la "huella digital" para el "digest" me parece confuso y excesivo.
# Yo lo reservaría para la huella digital de PGP. sv
# Propongo algo más sencillo:
# "No utiliza la suma md5 para verificar.". sv
#
# Sospecho que en realidad utiliza algún algoritmo llamado md5sum ya
# definido en alguna librería para hacer esta comprobación, y lo que
# realmente viene a utilizar es el "digest" que obtiene de esta función. tb
#
# Bueno, ahora está mejor que antes, pero se puede confundir el
# algoritmo con el programa que lo implementa con el resultado del algoritmo.
# (Siendo efectivamente esto último a lo que se refiere realmente).
# Pero mejor lo dejamos así, no vaya a ser que al intentar traducir
# `digest' quede peor... sv
#: src/shar.c:1780
msgid ""
"\n"
"Protecting against transmission:\n"
"  -w, --no-character-count      do not use `wc -c' to check size\n"
"  -D, --no-md5-digest           do not use `md5sum' digest to verify\n"
"  -F, --force-prefix            force the prefix character on every line\n"
"  -d, --here-delimiter=STRING   use STRING to delimit the files in the shar\n"
"\n"
"Producing different kinds of shars:\n"
"  -V, --vanilla-operation   produce very simple and undemanding shars\n"
"  -P, --no-piping           exclusively use temporary files at unshar time\n"
"  -x, --no-check-existing   blindly overwrite existing files\n"
"  -X, --query-user          ask user before overwriting files (not for Net)\n"
"  -m, --no-timestamp        do not restore file modification dates & times\n"
"  -Q, --quiet-unshar        avoid verbose messages at unshar time\n"
"  -f, --basename            restore in one directory, despite hierarchy\n"
"      --no-i18n             do not produce internationalized shell script\n"
msgstr ""
"\n"
"Protección contra transmisión:\n"
"  -w, --no-character-count     no usa `wc -c' para verificar el tamaño\n"
"  -D, --no-md5-digest          no utiliza `md5sum' para verificar\n"
"  -F, --force-prefix           fuerza el carácter de prefijo en todas\n"
"                               las líneas\n"
"  -d, --here-delimiter=CADENA  usa CADENA para delimitar los ficheros en\n"
"                               el archivo `shar'\n"
"\n"
"Producción de distintas clases de archivos `shar':\n"
"  -V, --vanilla-operation   produce archivos `shar' muy sencillos y\n"
"                            poco exigentes\n"
"  -P, --no-piping           usa exclusivamente archivos temporales al\n"
"                            deshacer el archivo `shar'\n"
"  -x, --no-check-existing   escribe sin confirmar sobre archivos\n"
"                            existentes\n"
"  -X, --query-user          pregunta al usuario antes de escribir sobre\n"
"                            archivos (no para red)\n"
"  -m, --no-timestamp        no restaura las fechas y horas de modificación\n"
"                            del fichero\n"
"  -Q, --quiet-unshar        impide producir mensajes al deshacer\n"
"                            el archivo `shar'\n"
"  -f, --basename            restaura en un directorio, sin tener en cuenta\n"
"                            la jerarquía\n"
"      --no-i18n             no produce `script' de shell internacionalizado\n"

#: src/shar.c:1798
msgid ""
"\n"
"Option -o is required with -l or -L, option -n is required with -a.\n"
msgstr ""
"\n"
"La opción -o es necesaria con -l o -L, la opción -n es necesaria con -a.\n"

#: src/shar.c:1802
msgid "Option -g implies -z, option -b implies -Z.\n"
msgstr "La opción -g implica -z, la opción -b implica -Z.\n"

#: src/shar.c:1805
msgid "Option -g implies -z.\n"
msgstr "La opción -g implica -z.\n"

# Nota: Lo del último traductor es provisional hasta que piense algo mejor.
#. TRANSLATORS: add the contact address for your translation team!
#: src/shar.c:1809 src/unshar.c:332 src/uudecode.c:450 src/uuencode.c:214
#, c-format
msgid "Report bugs to <%s>.\n"
msgstr ""
"Comunicar bichos a <%s>.\n"
"Comunicar errores de traducción al último traductor:\n"
" msgunfmt /usr/share/locale/es/LC_MESSAGES/sharutils.mo | grep Last-"
"Translator\n"

#: src/shar.c:1867
#, c-format
msgid "invalid file size limit `%s'"
msgstr "límite de tamaño de fichero inválido `%s'"

#: src/shar.c:1903
#, c-format
msgid "invalid format (count field too wide): '%s'\n"
msgstr "formato inválido (campo \"count\" demasiado ancho): '%s'\n"

#: src/shar.c:1964
msgid "DEBUG was not selected at compile time"
msgstr "No se seleccionó DEBUG en la compilación"

# ¿Límite fijo o infranqueable? ipg
# Buena pregunta. Quién podrá resolverla? tb
# El resolvedor que la resuelva buen resolvedor será ...
# Me sace que aquí se refiere al límite duro, al que es `no más Santo
# Tomás'. Según recuerdo, el soft es el que se te deja pasar (en las
# cuotas, por ejemplo) por un periodo de gracia, pasado el cual, te
# abren el culo. El hard es el que no puedes pasar ni hinchao de
# coca. Yo creo que traduciría `Soft limit' como `Límite de aviso' y
# `Hard limit' como 'Límite inexcedible'. ipg
# "límite por hardware" me parece perfecto. sv
#: src/shar.c:1984
#, c-format
msgid "Hard limit %s\n"
msgstr "Límite por hardware %s\n"

#: src/shar.c:2026
msgid "This system doesn't support -Z ('compress'), use -z instead"
msgstr "Este sistema no admite -Z ('compress'), utilice -z en su lugar"

# ¿Límite de aviso? ipg
# Otra buena pregunta. tb
# Me remito a la anterior respuesta :). ipg
#: src/shar.c:2059
#, c-format
msgid "Soft limit %s\n"
msgstr "Límite por software %s\n"

#: src/shar.c:2074
#, c-format
msgid "illegal output prefix\n"
msgstr "prefijo de salida ilegal\n"

#: src/shar.c:2121 src/unshar.c:415 src/uudecode.c:488 src/uuencode.c:254
#, c-format, no-wrap
msgid ""
"Copyright (C) %s Free Software Foundation, Inc.\n"
"This is free software; see the source for copying conditions.  There is NO\n"
"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
msgstr ""
"Copyright (C) %s Free Software Foundation, Inc.\n"
"Esto es software libre; vea el código fuente para las condiciones de copia.\n"
"No hay NINGUNA garantía; ni siquiera de COMERCIABILIDAD o IDONEIDAD PARA UN\n"
"FIN DETERMINADO.\n"

# ver arriba del todo.
# Lo cambio, con permiso. sv
#: src/shar.c:2168
msgid "WARNING: No user interaction in vanilla mode"
msgstr "ATENCIÓN: No se permite la interacción del usuario en modo `vanilla'"

# ¿overridden es ignoradas? tal y como ha quedado no me parece fiel.
# tal vez añadiendo las opciones por defecto o algo así. ¿qué te
# parece? sv Overriden, desde mi punto de vista, significa que a las
# opciones que se introdujeron "no se les hace caso" override". O sea,
# que... cómo lo ponemos? tb
# ¿sustituídas? sv
# Los alemanes usan algo como "sobreescritas". No es por nada, pero...
# no se sustituyen estas opciones: se descartan? Se pasan por alto?
#
# Se ignoran? tb
#
# Esto es delicado. Ignorar es "no saber", pero por culpa de la
# palabra inglesa "ignore", la gente está empezando a usar "ignorar" como
# sinónimo de lo que realmente significa "ignore": no hacer caso.
# (mantengo una lucha sin cuartel contra esta palabra con ese significado).
# ^^^ Ya será menos, Santiago ;) ipg (¡e broma :D!)
# En estos casos se pueden usar "descartar", "no tener efecto"
# "pasar por alto", y cosas así.
# ¿Te gusta alguna? sv
# Pues sí... `descartadas' no me disgusta. No sé si preferiría `desechadas'
# aunque a lo mejor alguien pondrá pegas. tb
#
# Sí, yo... me suena a desechos (desperdicios). No sé. sv
# Ya, ya lo sabía... Cambio a "descartadas" a ver. tb
#: src/shar.c:2180
msgid "WARNING: Non-text storage options overridden"
msgstr "ATENCIÓN: Descartadas las opciones de almacenamiento para no-texto"

# Sugerencia: "No hay ningún archivo de entrada". sv
# Apoyo la moción. ipg
# De acuerdo, en parte. tb
# Esta frase ya ha salido en otra ocasión.
# Si ponemos "No se han indicado archivos de entrada"
# el plural parece indicar que hay que dar varios archivos de entrada.
# Lo cambio, a ver si te gusta. sv
#: src/shar.c:2236
msgid "No input files"
msgstr "No hay archivos de entrada"

#: src/shar.c:2242
msgid "Cannot use -a option without -n"
msgstr "No se puede usar la opción -a sin -n"

#: src/shar.c:2248
msgid "Cannot use -l or -L option without -o"
msgstr "No se puede usar la opción -l o -L sin -o"

#: src/shar.c:2260
msgid "PLEASE avoid -X shars on Usenet or public networks"
msgstr ""
"POR FAVOR evite archivos creados con `shar -X' en Usenet o redes públicas"

#: src/shar.c:2301
msgid "You have unpacked the last part"
msgstr "Ha desempaquetado la última parte"

#: src/shar.c:2303
#, c-format
msgid "Created %d files\n"
msgstr "Se han creado %d archivos\n"

#: src/shar.c:2308
#, c-format
msgid "x - removed lock directory `'%s\\''."
msgstr "x - borrado el directorio de bloqueo `'%s\\''."

#: src/shar.c:2310
#, c-format
msgid "x - failed to remove lock directory `'%s\\''."
msgstr "x - fallo al borrar el directorio de bloqueo `'%s\\''."

#: src/unshar.c:169
#, c-format
msgid "Found no shell commands in %s"
msgstr "No se han encontrado comandos de shell en %s"

#: src/unshar.c:185
#, c-format
msgid "%s looks like raw C code, not a shell archive"
msgstr "%s parece código C, no un archivo de shell"

#: src/unshar.c:221
#, c-format
msgid "Found no shell commands after `cut' in %s"
msgstr "No se encontraron instrucciones de shell después de `cut' en %s"

#: src/unshar.c:242
#, c-format
msgid "%s is probably not a shell archive"
msgstr "%s probablemente no sea un archivo de shell"

#: src/unshar.c:243
#, c-format
msgid "The `cut' line was followed by: %s"
msgstr "La línea `cut' estaba seguida por: %s"

#: src/unshar.c:269
msgid "Starting `sh' process"
msgstr "Iniciando el proceso `sh'"

# guión -> `script'
# ¿concatenados o concadenados?
# ipg
# Por aquí usamos "concatenar", pero veo que es "concadenar". Cambiado. tb
# No lo lleves tan a misa :) que yo no estaba muy seguro. Ahora he
# mirado el diccionario, y resulta que ambas son válidas. Elige tú; a mí
# personalmente (y no sé por qué) me gusta más `concatenar'). ipg
# Y a mí también: es lo que la gente usa por aquí... tb
#: src/unshar.c:318
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
"\n"
"  -d, --directory=DIRECTORY   change to DIRECTORY before unpacking\n"
"  -c, --overwrite             pass -c to shar script for overwriting files\n"
"  -e, --exit-0                same as `--split-at=\"exit 0\"'\n"
"  -E, --split-at=STRING       split concatenated shars after STRING\n"
"  -f, --force                 same as `-c'\n"
"      --help                  display this help and exit\n"
"      --version               output version information and exit\n"
"\n"
"If no FILE, standard input is read.\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas\n"
"también son obligatorios para las opciones cortas.\n"
"\n"
"  -d, --directory=DIRECTORIO  cambia a DIRECTORIO antes de desempaquetar\n"
"  -c, --overwrite             pasa -c al `script' shar para sobreescribir\n"
"                              ficheros\n"
"  -e, --exit-0                igual que `--split-at=\"exit 0\"'\n"
"  -E, --split-at=CADENA       divide los archivos `shar' concatenados\n"
"                              tras encontrar CADENA\n"
"  -f, --force                 igual que `-c'\n"
"      --help                  muestra esta ayuda y finaliza\n"
"      --version               informa de la versión y finaliza\n"
"\n"
"Si no se indica FICHERO, entonces se lee la entrada estándar.\n"

#: src/unshar.c:395
#, c-format
msgid "Cannot chdir to `%s'"
msgstr "No se puede cambiar al directorio `%s'"

#: src/unshar.c:446 src/unshar.c:508
msgid "allocate file name buffer"
msgstr "reserva de espacio para el nombre del fichero"

#: src/unshar.c:467
msgid "standard input"
msgstr "entrada estándar"

#: src/unshar.c:529
msgid "allocate file buffer"
msgstr "reserva de espacio para el fichero"

#: src/uudecode.c:123 src/uudecode.c:427
#, c-format
msgid "%s: Write error"
msgstr "%s: Error de escritura"

#: src/uudecode.c:141 src/uudecode.c:229
#, c-format
msgid "%s: Short file"
msgstr "%s: Fichero cortado"

#: src/uudecode.c:177
#, c-format
msgid "%s: No `end' line"
msgstr "%s: No hay línea `end'"

#: src/uudecode.c:238
#, c-format
msgid "%s: data following `=' padding character"
msgstr "%s: datos posteriores al carácter de relleno `='"

# Preferiría "no válida". Pero vamos a dejarlo a ver qué opinan otros,
# ¿vale? tb
# Por mí, vale así, a ver qué dice Enrique cuando lo vea. sv
# (Pero que conste que yo te apoyo con lo de "ilegal") sv
# Yo opino que `no válida'. ipg
# Pues si ya somos tres, no creo que vaya a esperar mucho a poner `no válida'.
# A la próxima... tbd
# No, yo decía que por mí vale "ilegal". Prefiero ilegal. sv
#: src/uudecode.c:262 src/uudecode.c:270 src/uudecode.c:284
#, c-format
msgid "%s: illegal line"
msgstr "%s: línea ilegal"

# Aquí tal vez se podría añadir "ninguna".
# "No hay ninguna línea `begin'". sv+
#: src/uudecode.c:324
#, c-format
msgid "%s: No `begin' line"
msgstr "%s: No hay línea `begin'"

# Ver el código fuente. Igual no habría que traducir ~user. sv
# No sé qué es lo que convendría... tb
# Yo creo que no es ilegal. Eso está especificando que la terminología
# de ~<usuario> no está aceptada ... a mi me parece que vale. ipg
# A ver: tenía puesto "~usuario inexistente". Qu'e es lo que viene mejor
# entre esta opción, "~usuario no válido" y "~usuario ilegal"? tb
# ¡¡Joder!! Pues ahora ni me aclaro ni ná de ná, ¿sabes seguro si el
# mensaje se usa para decir que no se acepta la terminología ~<usuario>
# o porque el <usuario> dado no existe? Si es lo primero, que lo dudo,
# me inclino por ilegal, y si es la segunda, por poner `El usuario
# especificado no existe'. ipg
#: src/uudecode.c:356
#, c-format
msgid "%s: Illegal ~user"
msgstr "%s: ~usuario ilegal"

#: src/uudecode.c:363
#, c-format
msgid "%s: No user `%s'"
msgstr "%s: No hay ningún usuario `%s'"

#: src/uudecode.c:387
#, c-format
msgid "cannot access %s"
msgstr "no se puede acceder a %s"

#: src/uudecode.c:392
#, c-format
msgid "denied writing FIFO (%s)"
msgstr "denegada la escritura al FIFO (%s)"

#: src/uudecode.c:397
#, c-format
msgid "not following symlink (%s)"
msgstr "no se sigue al enlace (%s)"

#: src/uudecode.c:405
#, c-format
msgid "freopen of %s"
msgstr "Efectuando freopen sobre %s"

#: src/uudecode.c:411
#, c-format
msgid "chmod of %s"
msgstr "Efectuando chmod sobre %s"

#: src/uudecode.c:443
#, c-format
msgid "Usage: %s [FILE]...\n"
msgstr "Uso: %s [FICHERO]...\n"

#: src/uudecode.c:444
msgid ""
"Mandatory arguments to long options are mandatory to short options too.\n"
"  -o, --output-file=FILE   direct output to FILE\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas son también "
"obligatorios\n"
"para las opciones cortas.\n"
"\n"
"  -o, --output-file=FICHERO  dirige la salida hacia FICHERO\n"
"      --help                 muestra esta ayuda y finaliza\n"
"      --version              informa de la versión y finaliza\n"

#: src/uuencode.c:135 src/uuencode.c:303 src/uuencode.c:310
msgid "Write error"
msgstr "Error de escritura"

#: src/uuencode.c:157 src/uuencode.c:188 src/uuencode.c:190
msgid "Read error"
msgstr "Error de lectura"

#: src/uuencode.c:208
#, c-format
msgid "Usage: %s [INFILE] REMOTEFILE\n"
msgstr "Modo de empleo: %s [FICHERO-DE-ENTRADA] FICHERO-REMOTO\n"

#: src/uuencode.c:209
msgid ""
"\n"
"  -m, --base64    use base64 encoding as of RFC1521\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
msgstr ""
"\n"
"  -m, --base64    utiliza base64 como se indica en RFC1521\n"
"      --help      muestra esta ayuda y finaliza\n"
"      --version   informa de la versión y finaliza\n"

#: src/uuencode.c:275
#, c-format
msgid "fopen-ing %s"
msgstr "Efectuando fopen sobre %s"

#: src/uuencode.c:277
#, c-format
msgid "fstat-ing %s"
msgstr "Efectuando fstat sobre %s"
